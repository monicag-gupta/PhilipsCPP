
Smart Pointers (Header: <memory>)
std::unique_ptr<T>
Owns and manages a single object.
Cannot be copied, only moved.
#include <memory>
std::unique_ptr<int> p = std::make_unique<int>(42);
std::shared_ptr<T>
Reference-counted ownership.
Memory is deleted when the last shared_ptr goes out of scope.
#include <memory>
std::shared_ptr<int> p1 = std::make_shared<int>(100);
std::shared_ptr<int> p2 = p1; // Shared ownership
std::weak_ptr<T>
Used with shared_ptr to avoid cyclic references.
Does not contribute to reference count.
Benefits of Smart Pointers:
Automatic cleanup (RAII: Resource Acquisition Is Initialization).
No need for delete.
Avoid memory leaks.
Improved exception safety.





#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "Constructor\n"; }
    ~MyClass() { std::cout << "Destructor\n"; }
    void greet() { std::cout << "Hello!\n"; }
};

int main() {
    std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();
    ptr->greet();

    // No need to delete, automatic cleanup
    return 0;
}





Prefer automatic storage or smart pointers over raw new/delete.
Always initialize your pointers.
Avoid manual delete in modern C++ unless absolutely necessary.
Use RAII to manage all resources (not just memory: files, sockets, etc.)
Tools to Help
Valgrind (Linux) for memory leak detection.
Visual Leak Detector (Windows).
Compiler flags like -fsanitize=address (GCC/Clang).




Stack Allocation Example
void printNumber() {
    int x = 10;         // Allocated on stack
    std::cout << x;
} // x is automatically deallocated here

Heap Allocation Example
void printHeapNumber() {
    int* x = new int(20);    // Allocated on heap
    std::cout << *x;
    delete x;                // Must manually deallocate
}





Manual memory management pitfalls C++

1. Memory Leaks
Memory is allocated but never freed.
Example:
int* ptr = new int(10);
// Forgot to delete ptr
Problem: Every time this code runs, it consumes more memory that is never released.
2. Dangling Pointers
Using memory after it has been freed.
Example:
int* ptr = new int(42);
delete ptr;
// Now ptr is a dangling pointer
*ptr = 100;  // Undefined behavior
Problem: This can lead to crashes or silent corruption of other data.
3. Double Deletion
Calling delete twice on the same pointer.
Example:
int* ptr = new int(5);
delete ptr;
delete ptr;  // Undefined behavior
Problem: May crash the program or cause heap corruption.



#include <iostream>

void memoryLeakExample() {
    std::cout << "\n--- Memory Leak Example ---\n";
    int* ptr = new int(10);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    // Memory Leak: forgot to delete ptr
    // delete ptr;  // This line is missing intentionally to show the leak
    // Problem: If this function is called repeatedly, memory usage will grow
}

void danglingPointerExample() {
    std::cout << "\n--- Dangling Pointer Example ---\n";
    int* ptr = new int(42);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted." << std::endl;

    // Dangling Pointer: ptr still points to freed memory
    // Accessing it now causes undefined behavior
    *ptr = 100;  // UNDEFINED BEHAVIOR
    std::cout << "Modified dangling pointer value: " << *ptr << std::endl;
}

void doubleDeletionExample() {
    std::cout << "\n--- Double Deletion Example ---\n";
    int* ptr = new int(5);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted once." << std::endl;

    delete ptr;  // UNDEFINED BEHAVIOR: double delete
    std::cout << "Pointer deleted twice!" << std::endl;
}

int main() {
    memoryLeakExample();
    // Comment out one by one to observe errors
    danglingPointerExample();
    doubleDeletionExample();

    std::cout << "\nProgram finished (may crash or behave unexpectedly due to undefined behavior)." << std::endl;
    return 0;
}





4. Memory Corruption
Writing beyond allocated bounds.
Example:
int* arr = new int[3];
arr[3] = 10;  // Out of bounds (0-based indexing)
Problem: This overwrites adjacent memory, causing unpredictable behavior.
5. Mismatched Allocation/Deallocation
Using delete instead of delete[] and vice versa.
Example:
int* arr = new int[10];
delete arr;  // Should be delete[] arr;
Problem: May not call destructors correctly, leading to resource leaks or crashes.
6. Not Handling Allocation Failures
new throws std::bad_alloc if it fails (unless nothrow is used).
Example:
int* ptr = new int[1000000000];  // May throw if system is out of memory
Problem: If not caught, the program crashes.



#include <iostream>
#include <new>       // For std::bad_alloc
using namespace std;

void memoryCorruptionExample() {
    cout << "\n--- Memory Corruption Example ---\n";
    int* arr = new int[3];  // Allocating space for 3 integers: arr[0], arr[1], arr[2]

    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;

    // Memory Corruption: writing out of bounds
    arr[3] = 99;  // Undefined behavior: arr[3] is out of bounds

    cout << "Value beyond bounds arr[3]: " << arr[3] << " (this is invalid access!)" << endl;

    delete[] arr;
}

void mismatchedAllocationExample() {
    cout << "\n--- Mismatched Allocation/Deallocation Example ---\n";

    int* arr = new int[5];  // Allocated with new[]
    arr[0] = 42;

    // Wrong deallocation
    delete arr;  // Should be delete[] arr

    // Problem: May lead to resource leaks or runtime issues
    cout << "Mismatched delete executed (delete used instead of delete[])." << endl;
}

void allocationFailureExample() {
    cout << "\n--- Allocation Failure Handling Example ---\n";

    try {
        // Try allocating a huge block of memory (may fail)
        int* ptr = new int[1000000000];  // Depends on system; may throw bad_alloc

        cout << "Memory allocation succeeded (unexpected on low-memory systems)." << endl;
        delete[] ptr;
    }
    catch (const bad_alloc& e) {
        // Proper handling of allocation failure
        cerr << "Memory allocation failed: " << e.what() << endl;
    }

    // Optional: Using nothrow to avoid exceptions
    int* ptr2 = new(nothrow) int[1000000000];
    if (!ptr2) {
        cerr << "Memory allocation failed using nothrow." << endl;
    }
    else {
        cout << "Memory allocation with nothrow succeeded." << endl;
        delete[] ptr2;
    }
}

int main() {
    memoryCorruptionExample();       // ❌ Causes memory corruption
    mismatchedAllocationExample();   // ❌ Wrong deallocation method
    allocationFailureExample();      // ✅ Demonstrates exception and nothrow handling

    cout << "\nProgram finished (some parts may crash or behave unpredictably due to memory errors).\n";
    return 0;
}








