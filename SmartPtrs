
Smart Pointers (Header: <memory>)
std::unique_ptr<T>
Owns and manages a single object.
Cannot be copied, only moved.
#include <memory>
std::unique_ptr<int> p = std::make_unique<int>(42);
std::shared_ptr<T>
Reference-counted ownership.
Memory is deleted when the last shared_ptr goes out of scope.
#include <memory>
std::shared_ptr<int> p1 = std::make_shared<int>(100);
std::shared_ptr<int> p2 = p1; // Shared ownership
std::weak_ptr<T>
Used with shared_ptr to avoid cyclic references.
Does not contribute to reference count.
Benefits of Smart Pointers:
Automatic cleanup (RAII: Resource Acquisition Is Initialization).
No need for delete.
Avoid memory leaks.
Improved exception safety.





#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "Constructor\n"; }
    ~MyClass() { std::cout << "Destructor\n"; }
    void greet() { std::cout << "Hello!\n"; }
};

int main() {
    std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();
    ptr->greet();

    // No need to delete, automatic cleanup
    return 0;
}





Prefer automatic storage or smart pointers over raw new/delete.
Always initialize your pointers.
Avoid manual delete in modern C++ unless absolutely necessary.
Use RAII to manage all resources (not just memory: files, sockets, etc.)
Tools to Help
Valgrind (Linux) for memory leak detection.
Visual Leak Detector (Windows).
Compiler flags like -fsanitize=address (GCC/Clang).




Stack Allocation Example
void printNumber() {
    int x = 10;         // Allocated on stack
    std::cout << x;
} // x is automatically deallocated here

Heap Allocation Example
void printHeapNumber() {
    int* x = new int(20);    // Allocated on heap
    std::cout << *x;
    delete x;                // Must manually deallocate
}





Manual memory management pitfalls C++

1. Memory Leaks
Memory is allocated but never freed.
Example:
int* ptr = new int(10);
// Forgot to delete ptr
Problem: Every time this code runs, it consumes more memory that is never released.
2. Dangling Pointers
Using memory after it has been freed.
Example:
int* ptr = new int(42);
delete ptr;
// Now ptr is a dangling pointer
*ptr = 100;  // Undefined behavior
Problem: This can lead to crashes or silent corruption of other data.
3. Double Deletion
Calling delete twice on the same pointer.
Example:
int* ptr = new int(5);
delete ptr;
delete ptr;  // Undefined behavior
Problem: May crash the program or cause heap corruption.



#include <iostream>

void memoryLeakExample() {
    std::cout << "\n--- Memory Leak Example ---\n";
    int* ptr = new int(10);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    // Memory Leak: forgot to delete ptr
    // delete ptr;  // This line is missing intentionally to show the leak
    // Problem: If this function is called repeatedly, memory usage will grow
}

void danglingPointerExample() {
    std::cout << "\n--- Dangling Pointer Example ---\n";
    int* ptr = new int(42);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted." << std::endl;

    // Dangling Pointer: ptr still points to freed memory
    // Accessing it now causes undefined behavior
    *ptr = 100;  // UNDEFINED BEHAVIOR
    std::cout << "Modified dangling pointer value: " << *ptr << std::endl;
}

void doubleDeletionExample() {
    std::cout << "\n--- Double Deletion Example ---\n";
    int* ptr = new int(5);
    std::cout << "Allocated int with value: " << *ptr << std::endl;

    delete ptr;
    std::cout << "Pointer deleted once." << std::endl;

    delete ptr;  // UNDEFINED BEHAVIOR: double delete
    std::cout << "Pointer deleted twice!" << std::endl;
}

int main() {
    memoryLeakExample();
    // Comment out one by one to observe errors
    danglingPointerExample();
    doubleDeletionExample();

    std::cout << "\nProgram finished (may crash or behave unexpectedly due to undefined behavior)." << std::endl;
    return 0;
}





4. Memory Corruption
Writing beyond allocated bounds.
Example:
int* arr = new int[3];
arr[3] = 10;  // Out of bounds (0-based indexing)
Problem: This overwrites adjacent memory, causing unpredictable behavior.
5. Mismatched Allocation/Deallocation
Using delete instead of delete[] and vice versa.
Example:
int* arr = new int[10];
delete arr;  // Should be delete[] arr;
Problem: May not call destructors correctly, leading to resource leaks or crashes.
6. Not Handling Allocation Failures
new throws std::bad_alloc if it fails (unless nothrow is used).
Example:
int* ptr = new int[1000000000];  // May throw if system is out of memory
Problem: If not caught, the program crashes.



#include <iostream>
#include <new>       // For std::bad_alloc
using namespace std;

void memoryCorruptionExample() {
    cout << "\n--- Memory Corruption Example ---\n";
    int* arr = new int[3];  // Allocating space for 3 integers: arr[0], arr[1], arr[2]

    arr[0] = 1;
    arr[1] = 2;
    arr[2] = 3;

    // Memory Corruption: writing out of bounds
    arr[3] = 99;  // Undefined behavior: arr[3] is out of bounds

    cout << "Value beyond bounds arr[3]: " << arr[3] << " (this is invalid access!)" << endl;

    delete[] arr;
}

void mismatchedAllocationExample() {
    cout << "\n--- Mismatched Allocation/Deallocation Example ---\n";

    int* arr = new int[5];  // Allocated with new[]
    arr[0] = 42;

    // Wrong deallocation
    delete arr;  // Should be delete[] arr

    // Problem: May lead to resource leaks or runtime issues
    cout << "Mismatched delete executed (delete used instead of delete[])." << endl;
}

void allocationFailureExample() {
    cout << "\n--- Allocation Failure Handling Example ---\n";

    try {
        // Try allocating a huge block of memory (may fail)
        int* ptr = new int[1000000000];  // Depends on system; may throw bad_alloc

        cout << "Memory allocation succeeded (unexpected on low-memory systems)." << endl;
        delete[] ptr;
    }
    catch (const bad_alloc& e) {
        // Proper handling of allocation failure
        cerr << "Memory allocation failed: " << e.what() << endl;
    }

    // Optional: Using nothrow to avoid exceptions
    int* ptr2 = new(nothrow) int[1000000000];
    if (!ptr2) {
        cerr << "Memory allocation failed using nothrow." << endl;
    }
    else {
        cout << "Memory allocation with nothrow succeeded." << endl;
        delete[] ptr2;
    }
}

int main() {
    memoryCorruptionExample();       // ❌ Causes memory corruption
    mismatchedAllocationExample();   // ❌ Wrong deallocation method
    allocationFailureExample();      // ✅ Demonstrates exception and nothrow handling

    cout << "\nProgram finished (some parts may crash or behave unpredictably due to memory errors).\n";
    return 0;
}





7. Hidden Ownership Issues
Unclear which part of the code owns and is responsible for deleting a pointer.
Example:
void process(int* data);  // Who owns and deletes 'data'?
Problem: Can lead to leaks or double deletes due to poor ownership clarity.
8. Forgetting to Delete in All Code Paths
A return or exception skips the delete call.
Example:
int* ptr = new int(7);
if (some_condition) return;  // Memory leak
delete ptr;
Problem: Hard to track and fix when scattered across multiple returns or exceptions.




#include <iostream>
#include <stdexcept>
using namespace std;

// === 7. Hidden Ownership Problem ===
void process(int* data) {
    cout << "\n--- Hidden Ownership Issue ---\n";
    // Do something with data
    cout << "Processing data: " << *data << endl;

    // But: Who should delete data?
    // If we delete it here, caller must NOT delete it
    // If we don't delete, caller must remember to delete it

    // delete data;  // Uncommenting this may cause double delete if caller also deletes it
}

void hiddenOwnershipExample() {
    int* data = new int(42);
    process(data);

    // Unclear ownership: should we delete here or was it already deleted in process()?
    delete data;  // Double delete if process() already deleted it
}


// === 8. Forgetting to Delete in All Code Paths ===
void forgettingToDeleteExample(bool triggerEarlyReturn, bool triggerException) {
    cout << "\n--- Forgetting to Delete in All Code Paths ---\n";
    int* ptr = new int(7);
    cout << "Allocated: " << *ptr << endl;

    if (triggerEarlyReturn) {
        cout << "Early return — memory leak!\n";
        return;  // ❌ Leak: delete is never called
    }

    if (triggerException) {
        cout << "Throwing exception — memory leak!\n";
        throw runtime_error("Exception occurred");  // ❌ Leak: delete is skipped
    }

    delete ptr;  // ✅ Only happens in normal flow
    cout << "Deleted successfully.\n";
}

int main() {
    // Demonstrate Hidden Ownership
    hiddenOwnershipExample();

    // Demonstrate forgetting to delete on early return
    forgettingToDeleteExample(true, false);

    // Demonstrate forgetting to delete on exception
    try {
        forgettingToDeleteExample(false, true);
    } catch (const exception& ex) {
        cout << "Caught exception: " << ex.what() << endl;
    }

    cout << "\nProgram finished (some paths leak memory).\n";
    return 0;
}






#include <iostream>
class Employee {
    std::string* name;
public:
    Employee(const std::string& empName) {
        name = new std::string(empName);
    }
    void show() const {
        std::cout << "Employee Name: " << *name << std::endl;
    }
    ~Employee() {
        delete name;
    }
};
 
int main() {
    Employee* emp = new Employee("Alice");
    emp->show();
    delete emp;  // Must remember to delete
    return 0;
}




#include <iostream>
#include <memory>  // For smart pointers
class Employee {
    std::unique_ptr<std::string> name;
public:
    Employee(const std::string& empName)
        : name(std::make_unique<std::string>(empName)) {}
    void show() const {
        std::cout << "Employee Name: " << *name << std::endl;
    }
    // No need to manually define destructor!
};
 
int main() {
    std::unique_ptr<Employee> emp = std::make_unique<Employee>("Alice");
    emp->show();
    // Automatically deleted when going out of scope
    return 0;
}














