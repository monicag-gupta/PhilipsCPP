Measuring Performance in VS2022
Visual Studio includes profiling tools:
Step-by-step:
Build in Release mode with full optimization.
Go to Debug → Performance Profiler.
Select:
CPU Usage (find slow functions)
Instrumentation (detailed function timings)
Concurrency Visualizer (for multithreaded apps)
Run your program & analyze hot paths.




Build in Release mode with full optimization

Switch the build configuration to Release
Look at the toolbar at the top (usually next to the green Run/Debug button).
You’ll see a dropdown with Debug selected by default.
Change it to Release.
This already tells VS2022 to disable debug checks and turn on optimizations by default.
You need to tell Visual Studio to use C++20 in both Debug and Release modes: project -> Properties -> (ensure Configuration = Release) -> Configuration Properties → C/C++ → Language -> C++ Language Standard -> ISO C++20 Standard (/std:c++20) -> OK -> Rebuild Project
Extra performance:
Under C/C++ → Code Generation → Enable Enhanced Instruction Set, pick AVX2 (or AVX-512 if your CPU supports it).


Right-click your project → Properties.
In the left tree:
Go to Configuration: Release (top dropdown in the Properties window).
Under Configuration Properties → C/C++ → Optimization:
Optimization → Maximize Speed (/O2)
Inline Function Expansion → Any Suitable (/Ob2)
Favor Size or Speed → Favor fast code (/Ot)
Omit Frame Pointers → Yes (/Oy)
Whole Program Optimization → Enable
Under Configuration Properties → Linker → Optimization:
Link Time Code Generation → Use Link Time Code Generation (/LTCG






Bottleneck analysis only makes sense if you’re profiling code as it will run in production.
Set Configuration → Release
Enable:
/O2 — Maximize Speed
/GL — Whole Program Optimization
/arch:AVX2 — Use modern CPU instructions (if supported)
/std:c++20 — Make sure modern features compile
Narrowing Down Bottlenecks Tips:
Use [Instrumentation] instead of Sampling if you need exact timing.
In C++20, also look for:
Unnecessary copies → fix with const&, string_view, span
Inefficient algorithms → switch to better STL algorithm or parallel STL (std::execution::par)
Branch misprediction → hint with [[likely]] / [[unlikely]]
Memory allocations → profile allocation count with Diagnostic Tools → Memory Usage
 




#include <iostream>
#include <fstream>
#include <chrono>
#include <thread>
#include <filesystem>

void slowFunction() {
    std::string result;
    for (int i = 0; i < 20000; ++i) {
        result += "data";
    }
}

void mediumFunction() {
    std::string result;
    result.reserve(20000 * 4);
    for (int i = 0; i < 20000; ++i) {
        result += "data";
    }
}

void fastFunction() {
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
}

int main() {
    // Print working directory so you know where the file is saved
    std::cout << "Working directory: " << std::filesystem::current_path() << "\n";

    std::ofstream log("profile_output.txt");

    log << "Running demo with Instrumentation profiling...\n";

    auto start = std::chrono::high_resolution_clock::now();

    slowFunction();
    mediumFunction();
    fastFunction();

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    log << "Total time: " << duration.count() << " ms\n";
    log.close();

    return 0;
}





Problem code:
#include <iostream>
#include <string>
#include <vector>

// Function takes std::string by value (copy!)
std::string repeatString(std::string s, int times) {
    std::string result;
    for (int i = 0; i < times; ++i) {
        result += s;
    }
    return result;
}

// Function takes vector<int> by value (copy!)
int sumVector(std::vector<int> v) {
    int sum = 0;
    for (auto i : v) {
        sum += i;
    }
    return sum;
}

int main() {
    std::string largeString(10000, 'x');
    std::vector<int> largeVector(100000, 1);

    auto start = std::chrono::high_resolution_clock::now();
    auto repeated = repeatString(largeString, 10);
    auto sum = sumVector(largeVector);
    auto end = std::chrono::high_resolution_clock::now();

    std::cout << "Repeat string length: " << repeated.length() << "\n";
    std::cout << "Sum vector: " << sum << "\n";

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Duration (ms): " << duration.count() << "\n";

    return 0;
}





#include <iostream>
#include <string>
#include <string_view>
#include <vector>
#include <span>
#include <chrono>

// Using string_view and span to avoid copies
std::string repeatString(std::string_view s, int times) {
    std::string result;
    for (int i = 0; i < times; ++i) {
        result += s;
    }
    return result;
}

int sumVector(std::span<const int> v) {
    int sum = 0;
    for (auto i : v) {
        sum += i;
    }
    return sum;
}

int main() {
    std::string largeString(10000, 'x');
    std::vector<int> largeVector(100000, 1);

    auto start = std::chrono::high_resolution_clock::now();
    auto repeated = repeatString(largeString, 10);
    auto sum = sumVector(largeVector);
    auto end = std::chrono::high_resolution_clock::now();

    std::cout << "Repeat string length: " << repeated.length() << "\n";
    std::cout << "Sum vector: " << sum << "\n";

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Duration (ms): " << duration.count() << "\n";

    return 0;
}



const std::string& and const std::vector<int>& avoid copies on function calls.
std::string_view is a lightweight, non-owning view of a string (no copy).Perfect for read-only access to strings or substrings.
std::span allows a view over any contiguous sequence (array, vector, etc.) without copying.





Inefficient algorithms:

#include <iostream>
#include <vector>
#include <chrono>

int sumEvenNumbers(const std::vector<int>& v) {
    int sum = 0;
    for (int x : v) {
        if (x % 2 == 0) {
            sum += x;
        }
    }
    return sum;
}

int main() {
    std::vector<int> data(10000000);
    for (int i = 0; i < 10000000; ++i) {
        data[i] = i;
    }

    auto start = std::chrono::high_resolution_clock::now();

    int total = sumEvenNumbers(data);

    auto end = std::chrono::high_resolution_clock::now();

    std::cout << "Sum of even numbers: " << total << "\n";

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Time taken: " << duration.count() << " ms\n";

    return 0;
}





#include <iostream>
#include <vector>
#include <numeric>
#include <execution>
#include <chrono>

int sumEvenNumbersManual(const std::vector<int>& v) {
    int sum = 0;
    for (int x : v) {
        if (x % 2 == 0) sum += x;
    }
    return sum;
}

int sumEvenNumbersParallel(const std::vector<int>& v) {
    return std::transform_reduce(
        std::execution::par,
        v.begin(), v.end(),
        0,
        std::plus<>(),
        [](int x) { return (x % 2 == 0) ? x : 0; }
    );
}

int main() {
    std::vector<int> data(100000000);
    for (int i = 0; i < data.size(); ++i) {
        data[i] = i;
    }

    auto start = std::chrono::high_resolution_clock::now();
    int manualSum = sumEvenNumbersManual(data);
    auto end = std::chrono::high_resolution_clock::now();
    std::cout << "Manual sum: " << manualSum << "\n";
    std::cout << "Manual duration (ms): "
        << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "\n";

    start = std::chrono::high_resolution_clock::now();
    int parallelSum = sumEvenNumbersParallel(data);
    end = std::chrono::high_resolution_clock::now();
    std::cout << "Parallel sum: " << parallelSum << "\n";
    std::cout << "Parallel duration (ms): "
        << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "\n";

    return 0;
}




Fix 1: Use better STL algorithm (std::accumulate + std::copy_if or std::ranges in C++20)
This uses ranges views to filter evens lazily, then accumulate sum.
Cleaner and often more optimized by the compiler.
 
Fix 2: Use Parallel STL (std::execution::par) for speed
std::transform_reduce applies a transform ([](int x){...}) and reduces (sum) in parallel.
Takes advantage of multiple CPU cores.
Requires /std:c++17 or higher and Windows SDK that supports parallel STL.







