Containers or container classes store objects and data. There are in total seven standard “first-class” container classes  and three container adaptor classes and only seven header files that provide access to these containers or container adaptors.
Sequence Containers:  implement data structures which can be accessed in a sequential manner.
vector
list
deque
arrays
forward_list( Introduced in C++11)
Container Adaptors :  provide a different interface for sequential containers.
queue
priority_queue
stack
Associative Containers :  implement sorted data structures that can be quickly searched (O(log n) complexity).
set
multiset
map
multimap






STL containers are implemented as template classes. 
Sequence containers: are ordered collections in which each element has a certain position. Also known as sequential containers.
Predefined sequential containers in STL: vector, list, deque
Associative containers: are sorted collections in which the actual position of an element depends on its value due to a certain sorting criterion
Predefined associative containers in STL: set, map, multiset, multimap
Container Adapters: meet special needs
Predefined container adapters in STL: stack, queue, priority queue
Miscellaneous Containers : bitset, pair, valarray




Vector:

#include<iostream>
#include <vector>
using namespace std;
int main() {
    vector <int> vNums;
    int i;
    for (i=1; i<=5; ++i )
        vNums.push_back(i); //append elements
    for (i=0; i< vNums.size(); i++ )
        cout << vNums[ i ] << ' ';
    cout<<endl;
    vNums.erase(vNums.begin() );//remove first element
   cout<<endl;
    vNums.pop_back();//remove last element
   for (i = 0; i< vNums.size(); i++)
        cout << vNums[ i ] << ' ';
   cout<<endl;
   return 0;
}





STL – Containers : Deque

#include <iostream>
#include <deque>
using namespace std;
int main(int argc, char ** argv){
    deque <int> deNums;
    int i;
    for (i = 1; i<=5; ++i )
        deNums.push_back(i); // append elements
    for (i = 2; i <= 5; i++)
        deNums.push_front(i); // insert at front
    for (i = 0; i < deNums.size(); i++)
        cout << deNums[i] << ' ';
    cout<<endl;
    return 0;
}



STL – Containers : List

begin( ): It returns an iterator pointing to the first element in list.Its time complexity is O(1). 
end( ): It returns an iterator referring to the theoretical element(doesn’t point to an element) which follows the last element.Its time complexity is O(1). 
empty( ): It returns whether the list is empty or not.It returns 1 if the list is empty otherwise returns 0.Its time complexity is O(1). 
assign( ): It assigns new elements to the list by replacing its current elements and change its size accordingly.It time complexity is O(N).
back( ): It returns reference to the last element in the list.Its time complexity is O(1). 
erase( ): It removes a single element or the range of element from the list.Its time complexity is O(N). 
front( ): It returns reference to the first element in the list.Its time complexity is O(1). 
push_back( ): It adds a new element at the end of the list, after its current last element. Its time complexity is O(1). 
push_front( ): It adds a new element at the beginning of the list, before its current first element. Its time complexity is O(1). 
remove( ): It removes all the elements from the list, which are equal to given element. Its time complexity is O(N). 
pop_back( ): It removes the last element of the list, thus reducing its size by 1. Its time complexity is O(1). 
pop_front( ): It removes the first element of the list, thus reducing its size by 1. Its time complexity is O(1). 
insert( ): It insert new elements in the list before the element on the specified position. Its time complexity is O(N). 
reverse ( ): It reverses the order of elements in the list. Its time complexity is O(N). 
size( ): It returns the number of elements in the list. Its time complexity is O(1).



#include <iostream>
#include <list>
using namespace std;
void PrintList(list<int> nums) {
    while(!nums.empty()) {
        cout << nums.front() << ' '; // display 1st element
        nums.pop_front(); }// remove 1st element
    cout << endl;
}
int main(int argc, char ** argv){
    list<int> nums;
    for (int i=1; i<=5; ++i)
        nums.push_back(i);
    PrintList(nums); // 1 2 3 4 5
    nums.reverse(); PrintList(nums); // 5 4 3 2 1
    nums.sort(); PrintList(nums); // 1 2 3 4 5
    return 0;
}





// pair::pair example
#include <utility>      // std::pair, std::make_pair
#include <string>       // std::string
#include <iostream>     // std::cout

int main () {
  std::pair <std::string,double> product1;                     // default constructor
  std::pair <std::string,double> product2 ("tomatoes",2.30);   // value init
  std::pair <std::string,double> product3 (product2);          // copy constructor

  product1 = std::make_pair(std::string("lightbulbs"),0.99);   // using make_pair (move)

  product2.first = "shoes";                  // the type of first is string
  product2.second = 39.90;                   // the type of second is double

  std::cout << "The price of " << product1.first << " is $" << product1.second << '\n';
  std::cout << "The price of " << product2.first << " is $" << product2.second << '\n';
  std::cout << "The price of " << product3.first << " is $" << product3.second << '\n';
  return 0;
}





#include <iostream>
#include <set>
int main() {
	std::set<int> mymultiset;
	std::set<int>::iterator it;
	// set some initial values:
	for (int i = 1; i <= 5; i++) mymultiset.insert(i * 10);  // 10 20 30 40 50
	int myints[] = { 5,10,15 };
	mymultiset.insert(myints, myints + 3);
	std::cout << "myset contains:";
	for (it = mymultiset.begin(); it != mymultiset.end(); ++it)
		std::cout << ' ' << *it;
	std::cout << '\n';
	return 0;
}





#include <iostream>
#include <set>
int main() {
	std::multiset<int> mymultiset;
	std::multiset<int>::iterator it;
	// set some initial values:
	for (int i = 1; i <= 5; i++) mymultiset.insert(i * 10);  // 10 20 30 40 50
	int myints[] = { 5,10,15 };
	mymultiset.insert(myints, myints + 3);
	std::cout << "myset contains:";
	for (it = mymultiset.begin(); it != mymultiset.end(); ++it)
		std::cout << ' ' << *it;
	std::cout << '\n';
	return 0;
}




Map does not allow duplicate keys. Value can be changed, but key remains constant. 
Multimaps allow duplicates.
Maps/Multimaps are internally implemented using balanced binary trees. So are sorted for their keys.
Maps can be used as associative arrays. 
Multimaps can be used to simulate dictionary.
Map sort elements automatically based on key, so searching elements for a particular key is very fast. Searching elements that have particular value is slow.




at( ): Returns a reference to the mapped value of the element identified with key. Its time complexity is O(logN). 
count( ): searches the map for the elements mapped by the given key and returns the number of matches. As map stores each element with unique key, then it will return 1 if match if found otherwise return 0.Its time complexity is O(logN). 
clear( ): clears the map, by removing all the elements from the map and leaving it with its size 0.Its time complexity is O(N). 
begin( ): returns an iterator(explained above) referring to the first element of map.Its time complexity is O(1). 
end( ): returns an iterator referring to the theoretical element(doesn’t point to an element) which follows the last element. Its time complexity is O(1).
empty( ): checks whether the map is empty or not. It doesn’t modify the map. It returns 1 if the map is empty otherwise returns 0.Its time complexity is O(1).
erase( ): removes a single element or the range of element from the map.
find( ): Searches the map for the element with the given key, and returns an iterator to it, if it is present in the map otherwise it returns an iterator to the theoretical element which follows the last element of map. Its time complexity is O(logN). 
insert( ): insert a single element or the range of element in the map. Its time complexity is O(logN), when only element is inserted and O(1) when position is also given.




#include <iostream>
#include <string>
#include <map>
using namespace std;
int main(int argc, char ** argv) {
	map <int, string> mScores;
	mScores.insert(pair<int, string>(95, "I"));
	mScores.insert(pair<int, string>(92, "IA"));
	mScores.insert(pair<int, string>(98, "S"));
	mScores.insert(pair<int, string>(94, "M"));
	mScores.insert(pair<int, string>(92, "M"));
  	map <int, string> ::iterator it;
	for (it = mScores.begin(); it != mScores.end(); it++)
		cout << it->first << " - > " << it->second << endl;

	return 0;
}



#include <iostream>
#include <string>
#include <map>
using namespace std;
int main(int argc, char ** argv) {
	multimap <int, string> mScores;
	mScores.insert(pair<int, string>(95, "I"));
	mScores.insert(pair<int, string>(92, "Is"));
	mScores.insert(pair<int, string>(98, "S"));
	mScores.insert(pair<int, string>(94, "M"));
	mScores.insert(pair<int, string>(92, "Ma"));
  	mScores.insert(pair<int, string>(92, "Ma"));
	map <int, string> ::iterator it;
	for (it = mScores.begin(); it != mScores.end(); it++)
		cout << it->first << " - > " << it->second << endl;

	return 0;
}






Stack
Container that manages its elements by LIFO policy
Generally made out of deque

Queue
Container that manages its elements by FIFO policy 
Generally used to implement buffers and is made out of deque

Priority Queue
Container in which the elements have different priorities associated with them. Priority is based on sorting criterion. (next element is element with highest value)
Generally made out of vector







// stack::push/pop
#include <iostream>       // std::cout
#include <stack>          // std::stack

int main () {
  std::stack<int> mystack;
  for (int i=0; i<5; ++i) mystack.push(i);
  std::cout << "Popping out elements...";
  while (!mystack.empty())  {
     std::cout << ' ' << mystack.top();
     mystack.pop();
  }
  std::cout << '\n';
  return 0;
}






// queue::push/pop
#include <iostream>       // std::cin, std::cout
#include <queue>          // std::queue
int main () {
  std::queue<int> myqueue;
  int myint;
  std::cout << "Please enter some integers (enter 0 to end):\n";
  do {
    std::cin >> myint;
    myqueue.push (myint);
  } while (myint);
  std::cout << "myqueue contains: ";
  while (!myqueue.empty())  {
    std::cout << ' ' << myqueue.front();
    myqueue.pop();
  }
  std::cout << '\n';
  return 0;
}



#include <queue>
#include <iostream>
int main() {
	std::priority_queue<int> q;
	for (int n : {1, 8, 5, 6, 3, 4, 0, 9, 7, 2})
		q.push(n);
	while (!q.empty()) {
		std::cout << q.top() << " ";
		q.pop();
	}
	std::cout << '\n';
}







unordered_set stores unique elements (no duplicates).
It uses hashing internally, so average time complexity for insert/find/erase is O(1).
Order of elements is not guaranteed.
Fast for lookups compared to std::set.




#include <iostream>
#include <unordered_set>
#include <string>

int main() {
    // Create an unordered_set of strings
    std::unordered_set<std::string> cities;

    // Insert some cities
    cities.insert("Delhi");
    cities.insert("Mumbai");
    cities.insert("Chennai");
    cities.insert("Kolkata");

    // Try to insert a duplicate
    cities.insert("Delhi"); // Won't be added again

    // Display the contents
    std::cout << "Cities in the unordered_set:\n";
    for (const auto& city : cities) {
        std::cout << city << "\n";
    }

    // Check if a city exists
    std::string check = "Mumbai";
    if (cities.find(check) != cities.end()) {
        std::cout << check << " is in the set.\n";
    } else {
        std::cout << check << " is not in the set.\n";
    }

    // Remove a city
    cities.erase("Chennai");

    std::cout << "\nAfter removing Chennai:\n";
    for (const auto& city : cities) {
        std::cout << city << "\n";
    }

    return 0;
}







#include <iostream>
#include <unordered_set>
#include <string>

int main() {
    // Create an unordered_multiset of strings
    std::unordered_multiset<std::string> animals;

    // Insert some animals (including duplicates)
    animals.insert("Tiger");
    animals.insert("Elephant");
    animals.insert("Tiger");     // Duplicate allowed
    animals.insert("Leopard");
    animals.insert("Elephant");  // Duplicate allowed

    // Display contents
    std::cout << "Animals in the unordered_multiset:\n";
    for (const auto& animal : animals) {
        std::cout << animal << "\n";
    }

    // Count occurrences
    std::cout << "\nNumber of Tigers: " << animals.count("Tiger") << "\n";
    std::cout << "Number of Elephants: " << animals.count("Elephant") << "\n";

    // Erase all Tigers
    animals.erase("Tiger");

    std::cout << "\nAfter erasing all Tigers:\n";
    for (const auto& animal : animals) {
        std::cout << animal << "\n";
    }

    return 0;
}





#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    // Declare an unordered_map to store student names and their marks
    std::unordered_map<std::string, int> studentMarks;

    // Insert values
    studentMarks["Alice"] = 85;
    studentMarks["Bob"] = 90;
    studentMarks["Charlie"] = 78;

    // Update value
    studentMarks["Alice"] = 88;

    // Accessing values
    std::cout << "Marks of Alice: " << studentMarks["Alice"] << "\n";

    // Iterating through the unordered_map
    std::cout << "\nAll student marks:\n";
    for (const auto& pair : studentMarks) {
        std::cout << pair.first << " => " << pair.second << "\n";
    }

    // Find a key
    std::string name = "Charlie";
    if (studentMarks.find(name) != studentMarks.end()) {
        std::cout << "\nFound " << name << " with marks: " << studentMarks[name] << "\n";
    }

    // Erase a key
    studentMarks.erase("Bob");

    std::cout << "\nAfter erasing Bob:\n";
    for (const auto& pair : studentMarks) {
        std::cout << pair.first << " => " << pair.second << "\n";
    }

    return 0;
}













