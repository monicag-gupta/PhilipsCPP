Here’s a solid overview of best practices for cross-platform binary compatibility in C++, especially useful if you’re distributing libraries (static .lib / .a or dynamic .dll / .so) across different platforms like Windows, Linux, and macOS.
1. Use a Stable ABI (Application Binary Interface)
ABI defines how your compiled code interacts at the binary level:
Function calling conventions
Name mangling
Data structure layout
Object file format
Tip:
Avoid compiler-specific extensions unless guarded by #ifdef.
Use extern "C" for C-style exports to prevent name mangling differences.
Example:
extern "C" int add(int a, int b); // ABI stable across compilers

2. Keep Compiler & Standard Library Consistency
Different compilers and versions often generate incompatible binaries.
Best practice:
Document the compiler and STL version your library was built with.
Avoid mixing code compiled with different compiler vendors for the same binary.
On Windows, MSVC binaries may not link with MinGW or Clang binaries without adjustments.
3. Use Fixed-Width Integer Types
Avoid platform-dependent types like long (size differs between Win64 and Linux).
Prefer:
#include <cstdint>
int32_t, int64_t, uint32_t
Ensures data structure layout consistency.

4. Avoid Exposing STL Types in Public APIs
STL containers (like std::string, std::vector) may have different memory layouts across compiler versions or even between debug and release builds.
Solution: Use PImpl (Pointer-to-Implementation) idiom to hide implementation details.
Example (PImpl):
// MyClass.h
class MyClass {
public:
    MyClass();
    ~MyClass();
    void process();
private:
    struct Impl;     // forward declaration
    Impl* pImpl;     // pointer to hidden implementation
};
5. Beware of Structure Padding & Alignment
Structure layout can vary between platforms.
Use:
#pragma pack(push, 1)  // pack without padding
struct Data { char a; int b; };
#pragma pack(pop)
Or static_assert(sizeof(Data) == expected_size); for safety.
6. Avoid Exceptions Across Library Boundaries
Exception handling mechanisms differ between compilers and runtimes.
Either:
Catch exceptions inside the library and return error codes.
Or enforce consistent exception ABI settings across builds.



7. Symbol Exporting/Importing
On Windows:
#ifdef BUILD_DLL
#define API __declspec(dllexport)
#else
#define API __declspec(dllimport)
#endif
On Linux/macOS:
#define API __attribute__((visibility("default")))
Always hide unnecessary internal symbols.
8. Avoid RTTI & Virtual Functions Across Boundaries
dynamic_cast and virtual tables may differ between compilers.
If polymorphism is needed, ensure both caller and library are built with the same compiler and RTTI settings.

9. Be Careful with Inline Functions
If inlined code changes between versions, old binaries may break without recompilation.
Keep inline functions in headers and maintain backward compatibility.
10. Use Versioned Namespaces
Helps when releasing new versions without breaking older code.
namespace mylib_v1 { /* ... */ }
11. Testing Across Platforms
Use CI pipelines with Windows, Linux, and macOS builds.
Test with different compilers: MSVC, GCC, Clang.
Keep a binary compatibility test suite.


In short:
Hide implementation details (PImpl).
Keep ABI stable (avoid STL in APIs, fixed-width types).
Use consistent compilers & settings.
Export/import symbols carefully.
Test on all target platforms regularly.





A full Visual Studio 2022 C++ example that:
Builds both a static .lib and a shared .dll version of the same library.
Follows best practices for cross-platform binary compatibility (ABI stability, export/import macros, opaque pointers, etc.).
Includes a simple app that links to either version.
I’ll walk you through the full project layout, the cross-platform compatibility techniques, and the complete code.
 
Project Structure
We'll create three projects inside the same VS2022 solution:
CppLibraryStatic    → static library (.lib)
CppLibraryShared    → dynamic library (.dll + .lib import library)
CppLibraryApp       → console application (links to either .lib or .dll)
 
Cross-platform Export/Import Macro
include/CppLibraryExport.h
#pragma once
// Detect platform
#if defined(_WIN32) || defined(_WIN64)
  #define LIB_API_EXPORT __declspec(dllexport)
  #define LIB_API_IMPORT __declspec(dllimport)
#else
  #define LIB_API_EXPORT __attribute__((visibility("default")))
  #define LIB_API_IMPORT
#endif
 
// Decide whether to export or import symbols
#ifdef BUILDING_CPPLIBRARY
  #define LIB_API LIB_API_EXPORT
#else
  #define LIB_API LIB_API_IMPORT
#endif
This allows us to use the same header for both static and shared builds without breaking ABI.
 
Opaque Pointer Pattern (PImpl) for ABI Stability
include/Greeter.h
#pragma once
#include <memory>
#include <string>
#include "CppLibraryExport.h"
 
class LIB_API Greeter {
public:
    Greeter(const std::string& name);
    ~Greeter();
 
    Greeter(const Greeter&) = delete;            // No copy (can add deep copy later)
    Greeter& operator=(const Greeter&) = delete; // No assign
    Greeter(Greeter&&) noexcept;                 // Move allowed
    Greeter& operator=(Greeter&&) noexcept;
 
    void greet() const;
 
private:
    struct Impl;                  // Forward declaration
    std::unique_ptr<Impl> pImpl;  // Opaque pointer
};
This hides internal implementation from the public header → binary compatibility even if internals change.
 
Library Implementation
src/Greeter.cpp
 
#include "Greeter.h"
#include <iostream>
 
// Internal structure (hidden from header)
struct Greeter::Impl {
    std::string name;
    Impl(const std::string& n) : name(n) {}
};
 
Greeter::Greeter(const std::string& name)
    : pImpl(std::make_unique<Impl>(name)) {}
 
Greeter::~Greeter() = default;
 
Greeter::Greeter(Greeter&& other) noexcept = default;
Greeter& Greeter::operator=(Greeter&& other) noexcept = default;
 
void Greeter::greet() const {
    std::cout << "Hello, " << pImpl->name << "!" << std::endl;
}
 
Building Static Library (.lib)
Project: CppLibraryStatic
Type: Static Library (.lib)
Public headers: include/*.h
Source: src/*.cpp
Preprocessor Definition:
 
BUILDING_CPPLIBRARY
 
Building Shared Library (.dll)
Project: CppLibraryShared
Type: Dynamic-Link Library (.dll)
Public headers: include/*.h
Source: src/*.cpp
Preprocessor Definition:
 
BUILDING_CPPLIBRARY
 
App That Uses Either Version
main.cpp
#include "Greeter.h"
 
int main() {
    Greeter g("World");
    g.greet();
    return 0;
}
In CppLibraryApp project settings:
For static linking: Add CppLibraryStatic.lib to Linker → Input.
For DLL linking: Add CppLibraryShared.lib (import library) to Linker → Input.
Make sure CppLibraryShared.dll is in the same folder as the app executable.
 
Best Practices for Cross-Platform Binary Compatibility Applied
Export/Import Macros → Avoids symbol visibility issues.
Opaque PImpl Pattern → ABI stability across versions.
No STL in Public ABI (except std::string carefully) → avoids mismatches across compilers.
Deleted Copy Constructor → avoids accidental slicing.
Consistent Compiler Settings (/MD vs /MT, C++ standard version) → prevents CRT mismatches.
Versioned Namespace (optional) for future changes:
 
namespace mylib_v1 { ... }
 
How to Build in VS2022
Create a Solution.
Add CppLibraryStatic (Static Library project).
Add CppLibraryShared (DLL project).
Add CppLibraryApp (Console App).
Set include directory to $(SolutionDir)include for all projects.
Set Linker dependencies for app to either static or shared lib project.
Build → Run → Works for both .lib and .dll versions.









