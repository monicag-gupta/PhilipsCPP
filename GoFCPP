#include<iostream>
using namespace std;
class System {
private:
    string s;
    System(string ss) { s = ss; }
public:
    static System& getInstance(string ss) {
        static System theInstance(ss);
        return theInstance;
    }
    void prn() {
        std::cout << s << " says this works!\n";
    }
};
int main() {
    System& sys1 = System::getInstance("sys1");
    sys1.prn();
    System& sys2 = System::getInstance("sys2"); //not created again
    sys2.prn();
    if (&sys1 == &sys2)
        cout << "Equal";
    else
        cout << "Not equal";
}







#include <iostream>
#include <string>
using namespace std;
class Shape {
public:
	virtual void Draw() = 0;
	static Shape* Create(string type);
};
class Circle : public Shape {
public:
	void Draw() { cout << "I am circle" << endl; }
	friend class Shape;
};
class Square : public Shape {
public:
	void Draw() { cout << "I am square" << endl; }
	friend class Shape;
};
Shape* Shape::Create(string type) {
	if (type == "circle") return new Circle();
	if (type == "square") return new Square();
	return NULL;
}
int main() {
	Shape* obj1 = Shape::Create("circle");
	Shape* obj2 = Shape::Create("square");
	obj1->Draw();
	obj2->Draw();
}




#include <iostream>	
#include <string>	
using namespace std;
class Device {
public:
	virtual void send(string data) = 0;
};
class Wifi : public Device {
public:
	void send(string data) {
		cout << "Sent By Wifi: " << data << endl;
	}
};
class Bluetooth : public Device {
public:
	void send(string data) {
		cout << "Sent By Bluetooth: " << data << endl;
	}
};
// Problem: Multiple if every function for handle the environment
// Solution: Build Abstract Factory and get method
class AbstractFactory {
public:
	virtual Device* get(int) = 0;
};
class DeviceAbstractFactory : public AbstractFactory {
public:
	Device* get(int x) {
		if (x == 1) { return new Wifi; }
		else { return new Bluetooth; }
	}
};
int main() {
	AbstractFactory* abstractFactory = new DeviceAbstractFactory;
	Device* device;		device = abstractFactory->get(2);
	device->send("Abstract Factory Design Pattern Worked.");
}







#include <iostream>
#include <memory>
#include <string>
using namespace std;

// Subject Interface
class Account {
public:
    virtual void accessAccount() = 0;
    virtual ~Account() {}
};

// Real Subject
class BankAccount : public Account {
    string owner;
public:
    BankAccount(string o) : owner(o) {}
    void accessAccount() override {
        cout << "Access granted to " << owner << "'s bank account.\n";
    }
};

// Proxy
class BankAccountProxy : public Account {
    shared_ptr<BankAccount> realAccount;
    string password;
public:
    BankAccountProxy(shared_ptr<BankAccount> acct, string pwd)
        : realAccount(acct), password(pwd) {
    }

    void accessAccount() override {
        string input;
        cout << "Enter password to access account: ";
        cin >> input;
        if (input == password) {
            realAccount->accessAccount();
        }
        else {
            cout << "Access Denied: Invalid password.\n";
        }
    }
};

// Main Client
int main() {
    shared_ptr<BankAccount> real = make_shared<BankAccount>("Alice");
    BankAccountProxy proxy(real, "1234");

    proxy.accessAccount(); // Try with 1234 or wrong password
    return 0;
}








These design patterns are all about Class's objects communication. Behavioral patterns are those patterns that are most specifically concerned with communication between objects.

Chain of responsibility
A way of passing a request between a chain of objects
Command
Encapsulate a command request as an object
Interpreter
A way to include language elements in a program
Iterator
Sequentially access the elements of a collection
Mediator
Defines simplified communication between classes
Memento
Capture and restore an object's internal state
Null Object
Designed to act as a default value of an object
Observer
A way of notifying change to a number of classes
State
Alter an object's behavior when its state changes
Strategy
Encapsulates an algorithm inside a class
Template method
Defer the exact steps of an algorithm to a subclass
Visitor
Defines a new operation to a class without change






#include <iostream>
#include <string>
class Observer {
public:
	virtual ~Observer() {}
	virtual void on_message(const std::string&) = 0;
};
class MessageBoard {
	Observer& observer;
public:
	MessageBoard(Observer& obs) : observer(obs) {}
	void post(const std::string& str) {
		observer.on_message(str);
	}
};
class Writer : public Observer {
public:
	void on_message(const std::string& str) {
		std::cout << str << std::endl;
	}
};
void hello_world(MessageBoard& message_board) {
	message_board.post("Hello world!");
}
int main() {
	Writer writer;
	MessageBoard message_board(writer);
	hello_world(message_board);
	return 0;
}





