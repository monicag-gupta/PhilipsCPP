#include <iostream>
#include <type_traits>

template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is integral.\n";
}

template<typename T>
typename std::enable_if<!std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is NOT integral.\n";
}

int main() {
    print(42);     // integral
    print(3.14);   // NOT integral
}









#include <iostream>
#include <typeinfo>

int main() {
    int x = 10;
    double y = 3.14;

    decltype(x) a = 5;     // 'a' is of type int
    decltype(y) b = 2.5;   // 'b' is of type double

    std::cout << typeid(a).name() << "\n"; // Usually prints "i" (int)
    std::cout << typeid(b).name() << "\n"; // Usually prints "d" (double)
}







With Expressions
decltype can deduce types from expressions:
int i = 0;
decltype(i + 2.5) result; // 'result' will be double because i + 2.5 is double
With Functions
int foo() { return 42; }
decltype(foo()) val = foo(); // val is int
Important Rule: Value Categories
decltype behaves differently based on value category:
int x = 5;
int& ref = x;
decltype(x)   a = x; // int
decltype(ref) b = x; // int&   (reference preserved)
decltype((x)) c = x; // int&   (note the extra parentheses!)
Without parentheses → you get the declared type.
With parentheses → expression form, may yield reference type.













