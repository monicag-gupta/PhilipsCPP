#include <iostream>
#include <type_traits>

template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is integral.\n";
}

template<typename T>
typename std::enable_if<!std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is NOT integral.\n";
}

int main() {
    print(42);     // integral
    print(3.14);   // NOT integral
}









#include <iostream>
#include <typeinfo>

int main() {
    int x = 10;
    double y = 3.14;

    decltype(x) a = 5;     // 'a' is of type int
    decltype(y) b = 2.5;   // 'b' is of type double

    std::cout << typeid(a).name() << "\n"; // Usually prints "i" (int)
    std::cout << typeid(b).name() << "\n"; // Usually prints "d" (double)
}







With Expressions
decltype can deduce types from expressions:
int i = 0;
decltype(i + 2.5) result; // 'result' will be double because i + 2.5 is double
With Functions
int foo() { return 42; }
decltype(foo()) val = foo(); // val is int
Important Rule: Value Categories
decltype behaves differently based on value category:
int x = 5;
int& ref = x;
decltype(x)   a = x; // int
decltype(ref) b = x; // int&   (reference preserved)
decltype((x)) c = x; // int&   (note the extra parentheses!)
Without parentheses → you get the declared type.
With parentheses → expression form, may yield reference type.







Common Use Cases
Generic programming: deducing return types
Template metaprogramming
With auto to tie variable type to another expression’s type.

Example in templates:
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}
Here:
decltype(a + b) ensures return type matches the result of adding a and b.








#include <iostream>
#include <typeinfo>
#include <string>

int foo() { return 42; } // Example function

// Generic template function using decltype to deduce return type
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    std::cout << std::boolalpha;

    // 1️. With Expressions
    int i = 0;
    decltype(i + 2.5) result = i + 2.5; // double
    std::cout << "decltype(i + 2.5) -> " << typeid(result).name()
        << " value: " << result << "\n";

    // 2️. With Functions
    decltype(foo()) val = foo(); // int
    std::cout << "decltype(foo()) -> " << typeid(val).name()
        << " value: " << val << "\n";

    // 3️. Value Categories
    int x = 5;
    int& ref = x;

    decltype(x)   a = x; // int
    decltype(ref) b = x; // int& (reference preserved)
    decltype((x)) c = x; // int& (expression, yields reference)

    a = 10;
    b = 20; // changes x
    c = 30; // also changes x

    std::cout << "decltype(x) a = " << a << "\n";
    std::cout << "decltype(ref) b = " << b << "\n";
    std::cout << "decltype((x)) c = " << c << "\n";
    std::cout << "x after b and c changes: " << x << "\n";

    // 4️. Common Use Case - Templates
    auto sum1 = add(2, 3.5);         // deduced double
    auto sum2 = add(std::string("Hello, "), std::string("World!")); // deduced std::string

    std::cout << "add(2, 3.5) -> " << sum1 << " (" << typeid(sum1).name() << ")\n";
    std::cout << "add(strings) -> " << sum2 << " (" << typeid(sum2).name() << ")\n";

    return 0;
}





#include <iostream>
#include <type_traits>

template <typename T>
void printTypeInfo(T value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << value << " is integral.\n";
    }
    else if constexpr (std::is_floating_point_v<T>) {
        std::cout << value << " is floating point.\n";
    }
    else {
        std::cout << "Unknown type.\n";
    }
}
int main() {
    printTypeInfo(42);     // 42 is integral.
    printTypeInfo(3.14);   // 3.14 is floating point.
    printTypeInfo("Hi");   // Unknown type.
}







