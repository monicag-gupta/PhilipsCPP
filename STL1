Containers or container classes store objects and data. There are in total seven standard “first-class” container classes  and three container adaptor classes and only seven header files that provide access to these containers or container adaptors.
Sequence Containers:  implement data structures which can be accessed in a sequential manner.
vector
list
deque
arrays
forward_list( Introduced in C++11)
Container Adaptors :  provide a different interface for sequential containers.
queue
priority_queue
stack
Associative Containers :  implement sorted data structures that can be quickly searched (O(log n) complexity).
set
multiset
map
multimap






STL containers are implemented as template classes. 
Sequence containers: are ordered collections in which each element has a certain position. Also known as sequential containers.
Predefined sequential containers in STL: vector, list, deque
Associative containers: are sorted collections in which the actual position of an element depends on its value due to a certain sorting criterion
Predefined associative containers in STL: set, map, multiset, multimap
Container Adapters: meet special needs
Predefined container adapters in STL: stack, queue, priority queue
Miscellaneous Containers : bitset, pair, valarray




Vector:

#include<iostream>
#include <vector>
using namespace std;
int main() {
    vector <int> vNums;
    int i;
    for (i=1; i<=5; ++i )
        vNums.push_back(i); //append elements
    for (i=0; i< vNums.size(); i++ )
        cout << vNums[ i ] << ' ';
    cout<<endl;
    vNums.erase(vNums.begin() );//remove first element
   cout<<endl;
    vNums.pop_back();//remove last element
   for (i = 0; i< vNums.size(); i++)
        cout << vNums[ i ] << ' ';
   cout<<endl;
   return 0;
}





STL – Containers : Deque

#include <iostream>
#include <deque>
using namespace std;
int main(int argc, char ** argv){
    deque <int> deNums;
    int i;
    for (i = 1; i<=5; ++i )
        deNums.push_back(i); // append elements
    for (i = 2; i <= 5; i++)
        deNums.push_front(i); // insert at front
    for (i = 0; i < deNums.size(); i++)
        cout << deNums[i] << ' ';
    cout<<endl;
    return 0;
}



STL – Containers : List

begin( ): It returns an iterator pointing to the first element in list.Its time complexity is O(1). 
end( ): It returns an iterator referring to the theoretical element(doesn’t point to an element) which follows the last element.Its time complexity is O(1). 
empty( ): It returns whether the list is empty or not.It returns 1 if the list is empty otherwise returns 0.Its time complexity is O(1). 
assign( ): It assigns new elements to the list by replacing its current elements and change its size accordingly.It time complexity is O(N).
back( ): It returns reference to the last element in the list.Its time complexity is O(1). 
erase( ): It removes a single element or the range of element from the list.Its time complexity is O(N). 
front( ): It returns reference to the first element in the list.Its time complexity is O(1). 
push_back( ): It adds a new element at the end of the list, after its current last element. Its time complexity is O(1). 
push_front( ): It adds a new element at the beginning of the list, before its current first element. Its time complexity is O(1). 
remove( ): It removes all the elements from the list, which are equal to given element. Its time complexity is O(N). 
pop_back( ): It removes the last element of the list, thus reducing its size by 1. Its time complexity is O(1). 
pop_front( ): It removes the first element of the list, thus reducing its size by 1. Its time complexity is O(1). 
insert( ): It insert new elements in the list before the element on the specified position. Its time complexity is O(N). 
reverse ( ): It reverses the order of elements in the list. Its time complexity is O(N). 
size( ): It returns the number of elements in the list. Its time complexity is O(1).



#include <iostream>
#include <list>
using namespace std;
void PrintList(list<int> nums) {
    while(!nums.empty()) {
        cout << nums.front() << ' '; // display 1st element
        nums.pop_front(); }// remove 1st element
    cout << endl;
}
int main(int argc, char ** argv){
    list<int> nums;
    for (int i=1; i<=5; ++i)
        nums.push_back(i);
    PrintList(nums); // 1 2 3 4 5
    nums.reverse(); PrintList(nums); // 5 4 3 2 1
    nums.sort(); PrintList(nums); // 1 2 3 4 5
    return 0;
}





// pair::pair example
#include <utility>      // std::pair, std::make_pair
#include <string>       // std::string
#include <iostream>     // std::cout

int main () {
  std::pair <std::string,double> product1;                     // default constructor
  std::pair <std::string,double> product2 ("tomatoes",2.30);   // value init
  std::pair <std::string,double> product3 (product2);          // copy constructor

  product1 = std::make_pair(std::string("lightbulbs"),0.99);   // using make_pair (move)

  product2.first = "shoes";                  // the type of first is string
  product2.second = 39.90;                   // the type of second is double

  std::cout << "The price of " << product1.first << " is $" << product1.second << '\n';
  std::cout << "The price of " << product2.first << " is $" << product2.second << '\n';
  std::cout << "The price of " << product3.first << " is $" << product3.second << '\n';
  return 0;
}





#include <iostream>
#include <set>
int main() {
	std::set<int> mymultiset;
	std::set<int>::iterator it;
	// set some initial values:
	for (int i = 1; i <= 5; i++) mymultiset.insert(i * 10);  // 10 20 30 40 50
	int myints[] = { 5,10,15 };
	mymultiset.insert(myints, myints + 3);
	std::cout << "myset contains:";
	for (it = mymultiset.begin(); it != mymultiset.end(); ++it)
		std::cout << ' ' << *it;
	std::cout << '\n';
	return 0;
}





#include <iostream>
#include <set>
int main() {
	std::multiset<int> mymultiset;
	std::multiset<int>::iterator it;
	// set some initial values:
	for (int i = 1; i <= 5; i++) mymultiset.insert(i * 10);  // 10 20 30 40 50
	int myints[] = { 5,10,15 };
	mymultiset.insert(myints, myints + 3);
	std::cout << "myset contains:";
	for (it = mymultiset.begin(); it != mymultiset.end(); ++it)
		std::cout << ' ' << *it;
	std::cout << '\n';
	return 0;
}




Map does not allow duplicate keys. Value can be changed, but key remains constant. 
Multimaps allow duplicates.
Maps/Multimaps are internally implemented using balanced binary trees. So are sorted for their keys.
Maps can be used as associative arrays. 
Multimaps can be used to simulate dictionary.
Map sort elements automatically based on key, so searching elements for a particular key is very fast. Searching elements that have particular value is slow.




at( ): Returns a reference to the mapped value of the element identified with key. Its time complexity is O(logN). 
count( ): searches the map for the elements mapped by the given key and returns the number of matches. As map stores each element with unique key, then it will return 1 if match if found otherwise return 0.Its time complexity is O(logN). 
clear( ): clears the map, by removing all the elements from the map and leaving it with its size 0.Its time complexity is O(N). 
begin( ): returns an iterator(explained above) referring to the first element of map.Its time complexity is O(1). 
end( ): returns an iterator referring to the theoretical element(doesn’t point to an element) which follows the last element. Its time complexity is O(1).
empty( ): checks whether the map is empty or not. It doesn’t modify the map. It returns 1 if the map is empty otherwise returns 0.Its time complexity is O(1).
erase( ): removes a single element or the range of element from the map.
find( ): Searches the map for the element with the given key, and returns an iterator to it, if it is present in the map otherwise it returns an iterator to the theoretical element which follows the last element of map. Its time complexity is O(logN). 
insert( ): insert a single element or the range of element in the map. Its time complexity is O(logN), when only element is inserted and O(1) when position is also given.




#include <iostream>
#include <string>
#include <map>
using namespace std;
int main(int argc, char ** argv) {
	map <int, string> mScores;
	mScores.insert(pair<int, string>(95, "I"));
	mScores.insert(pair<int, string>(92, "IA"));
	mScores.insert(pair<int, string>(98, "S"));
	mScores.insert(pair<int, string>(94, "M"));
	mScores.insert(pair<int, string>(92, "M"));
  	map <int, string> ::iterator it;
	for (it = mScores.begin(); it != mScores.end(); it++)
		cout << it->first << " - > " << it->second << endl;

	return 0;
}



#include <iostream>
#include <string>
#include <map>
using namespace std;
int main(int argc, char ** argv) {
	multimap <int, string> mScores;
	mScores.insert(pair<int, string>(95, "I"));
	mScores.insert(pair<int, string>(92, "Is"));
	mScores.insert(pair<int, string>(98, "S"));
	mScores.insert(pair<int, string>(94, "M"));
	mScores.insert(pair<int, string>(92, "Ma"));
  	mScores.insert(pair<int, string>(92, "Ma"));
	map <int, string> ::iterator it;
	for (it = mScores.begin(); it != mScores.end(); it++)
		cout << it->first << " - > " << it->second << endl;

	return 0;
}






Stack
Container that manages its elements by LIFO policy
Generally made out of deque

Queue
Container that manages its elements by FIFO policy 
Generally used to implement buffers and is made out of deque

Priority Queue
Container in which the elements have different priorities associated with them. Priority is based on sorting criterion. (next element is element with highest value)
Generally made out of vector







// stack::push/pop
#include <iostream>       // std::cout
#include <stack>          // std::stack

int main () {
  std::stack<int> mystack;
  for (int i=0; i<5; ++i) mystack.push(i);
  std::cout << "Popping out elements...";
  while (!mystack.empty())  {
     std::cout << ' ' << mystack.top();
     mystack.pop();
  }
  std::cout << '\n';
  return 0;
}






// queue::push/pop
#include <iostream>       // std::cin, std::cout
#include <queue>          // std::queue
int main () {
  std::queue<int> myqueue;
  int myint;
  std::cout << "Please enter some integers (enter 0 to end):\n";
  do {
    std::cin >> myint;
    myqueue.push (myint);
  } while (myint);
  std::cout << "myqueue contains: ";
  while (!myqueue.empty())  {
    std::cout << ' ' << myqueue.front();
    myqueue.pop();
  }
  std::cout << '\n';
  return 0;
}



#include <queue>
#include <iostream>
int main() {
	std::priority_queue<int> q;
	for (int n : {1, 8, 5, 6, 3, 4, 0, 9, 7, 2})
		q.push(n);
	while (!q.empty()) {
		std::cout << q.top() << " ";
		q.pop();
	}
	std::cout << '\n';
}







unordered_set stores unique elements (no duplicates).
It uses hashing internally, so average time complexity for insert/find/erase is O(1).
Order of elements is not guaranteed.
Fast for lookups compared to std::set.




#include <iostream>
#include <unordered_set>
#include <string>

int main() {
    // Create an unordered_set of strings
    std::unordered_set<std::string> cities;

    // Insert some cities
    cities.insert("Delhi");
    cities.insert("Mumbai");
    cities.insert("Chennai");
    cities.insert("Kolkata");

    // Try to insert a duplicate
    cities.insert("Delhi"); // Won't be added again

    // Display the contents
    std::cout << "Cities in the unordered_set:\n";
    for (const auto& city : cities) {
        std::cout << city << "\n";
    }

    // Check if a city exists
    std::string check = "Mumbai";
    if (cities.find(check) != cities.end()) {
        std::cout << check << " is in the set.\n";
    } else {
        std::cout << check << " is not in the set.\n";
    }

    // Remove a city
    cities.erase("Chennai");

    std::cout << "\nAfter removing Chennai:\n";
    for (const auto& city : cities) {
        std::cout << city << "\n";
    }

    return 0;
}







#include <iostream>
#include <unordered_set>
#include <string>

int main() {
    // Create an unordered_multiset of strings
    std::unordered_multiset<std::string> animals;

    // Insert some animals (including duplicates)
    animals.insert("Tiger");
    animals.insert("Elephant");
    animals.insert("Tiger");     // Duplicate allowed
    animals.insert("Leopard");
    animals.insert("Elephant");  // Duplicate allowed

    // Display contents
    std::cout << "Animals in the unordered_multiset:\n";
    for (const auto& animal : animals) {
        std::cout << animal << "\n";
    }

    // Count occurrences
    std::cout << "\nNumber of Tigers: " << animals.count("Tiger") << "\n";
    std::cout << "Number of Elephants: " << animals.count("Elephant") << "\n";

    // Erase all Tigers
    animals.erase("Tiger");

    std::cout << "\nAfter erasing all Tigers:\n";
    for (const auto& animal : animals) {
        std::cout << animal << "\n";
    }

    return 0;
}





#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    // Declare an unordered_map to store student names and their marks
    std::unordered_map<std::string, int> studentMarks;

    // Insert values
    studentMarks["Alice"] = 85;
    studentMarks["Bob"] = 90;
    studentMarks["Charlie"] = 78;

    // Update value
    studentMarks["Alice"] = 88;

    // Accessing values
    std::cout << "Marks of Alice: " << studentMarks["Alice"] << "\n";

    // Iterating through the unordered_map
    std::cout << "\nAll student marks:\n";
    for (const auto& pair : studentMarks) {
        std::cout << pair.first << " => " << pair.second << "\n";
    }

    // Find a key
    std::string name = "Charlie";
    if (studentMarks.find(name) != studentMarks.end()) {
        std::cout << "\nFound " << name << " with marks: " << studentMarks[name] << "\n";
    }

    // Erase a key
    studentMarks.erase("Bob");

    std::cout << "\nAfter erasing Bob:\n";
    for (const auto& pair : studentMarks) {
        std::cout << pair.first << " => " << pair.second << "\n";
    }

    return 0;
}







#include <iostream>
#include <unordered_set>
#include <string>
using namespace std;

int main() {
    // Create an unordered_set of strings
    std::unordered_set<std::string> cities;

    // Insert some cities
    cities.insert("Delhi");
    cities.insert("Mumbai");
    cities.insert("Chennai");
    cities.insert("Kolkata");
    auto x = cities.insert("Kolkata");
    cout << "Return value " << x.second <<"\n\n\n\n";
    // Try to insert a duplicate
    cities.insert("Delhi"); // Won't be added again

    // Display the contents
    std::cout << "Cities in the unordered_set:\n";
    for (const auto& city : cities) {
        std::cout << city << "\n";
    }

    // Check if a city exists
    std::string check = "Mumbai";
    if (cities.find(check) != cities.end()) {
        std::cout << check << " is in the set.\n";
    }
    else {
        std::cout << check << " is not in the set.\n";
    }

    // Remove a city
    cities.erase("Chennai");

    std::cout << "\nAfter removing Chennai:\n";
    for (const auto& city : cities) {
        std::cout << city << "\n";
    }

    return 0;
}











#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    // Declare an unordered_map to store student names and their marks
    std::unordered_map<std::string, int> studentMarks;

    // Insert values
    studentMarks["Alice"] = 85;
    studentMarks["Bob"] = 90;
    studentMarks["Charlie"] = 78;

    // Update value
    studentMarks["Alice"] = 88;

    // Accessing values
    std::cout << "Marks of Alice: " << studentMarks["Alice"] << "\n";

    // Iterating through the unordered_map
    std::cout << "\nAll student marks:\n";
    for (const auto& pair : studentMarks) {
        std::cout << pair.first << " => " << pair.second << "\n";
    }

    // Find a key
    std::string name = "Charlie";
    if (studentMarks.find(name) != studentMarks.end()) {
        std::cout << "\nFound " << name << " with marks: " << studentMarks[name] << "\n";
    }

    // Erase a key
    studentMarks.erase("Bob");

    std::cout << "\nAfter erasing Bob:\n";
    for (const auto& pair : studentMarks) {
        std::cout << pair.first << " => " << pair.second << "\n";
    }

    return 0;
}







#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    // Create an unordered_multimap of department and employee names
    std::unordered_multimap<std::string, std::string> departmentEmployees;

    // Insert key-value pairs (duplicate keys allowed)
    departmentEmployees.insert({"HR", "Alice"});
    departmentEmployees.insert({"IT", "Bob"});
    departmentEmployees.insert({"HR", "Charlie"});
    departmentEmployees.insert({"IT", "David"});
    departmentEmployees.insert({"Finance", "Eve"});

    // Print all values
    std::cout << "Department -> Employees:\n";
    for (const auto& entry : departmentEmployees) {
        std::cout << entry.first << " -> " << entry.second << "\n";
    }

    // Count how many employees in HR
    std::string dept = "HR";
    int count = departmentEmployees.count(dept);
    std::cout << "\nNumber of employees in " << dept << ": " << count << "\n";

    // Get all employees in IT
    std::cout << "\nEmployees in IT department:\n";
    auto range = departmentEmployees.equal_range("IT");
    for (auto it = range.first; it != range.second; ++it) {
        std::cout << it->second << "\n";
    }

    return 0;
}









#include <iostream>
#include <vector>
#include <cctype>
using namespace std;
int main(int argc, char** argv) {
    vector <char> vNames;
    for (char ch = 'a'; ch <= 'z'; ++ch)
        vNames.push_back(ch);

    vector <char> ::iterator it;
    for (it = vNames.begin(); it != vNames.end(); it++)
        cout << *it;
    for (it = vNames.begin(); it != vNames.end(); it++)
        *it = toupper(*it);
    for (it = vNames.begin(); it != vNames.end(); it++)
        cout << *it;
    return 0;
}






#include<iostream>
#include<vector> 
using namespace std;
int main() {
	vector<int> v1 = { 10, 20, 30, 40, 50 };
	vector<int>::iterator i1, i2;
	for (i2 = v1.end() - 1;i2 != v1.begin();--i2) {
	// Accessing values at locations pointed by bidirectional Iterator
		cout << (*i2) << " ";
	} 
 	cout << (*i2)<<endl;
	for (i1 = v1.begin();i1 != v1.end();++i1) {
	// Assigning values to locations pointed by  Output iterator 
		*i1 = 1;
	} // v1 becomes 1 1 1 1 1
	for (i1 = v1.begin();i1 != v1.end();++i1) {
	// Accessing values at locations pointed by Input Iterator
		cout << (*i1) << " ";
	}
	return 0;
}





STL - container selection guidelines

Vector is used in place of dynamically allocated array
List allows dynamically changing size for linear access
Set is used when we need to keep data sorted
Map is used when we want indexed data
Multi(set/map) is used when we need multiple keys




Trade-offs

1. std::vector
Pros:
Fast random access (O(1))
Good cache locality (elements stored contiguously)
Efficient insertions/removals at the end (O(1) amortized)
Cons:
Inserting/removing in the middle or front is expensive (O(n))
Reallocation may invalidate pointers/references/iterators
Use When: You need fast access and mostly add to the end.
2. std::deque
Pros:
Fast insertions/removals at both ends (O(1))
No reallocation like vector (uses blocks of memory)
Cons:
No contiguous storage → worse cache performance than vector
Random access slower than vector
Use When: You need frequent push/pop at both ends.


3. std::list (Doubly Linked List)
Pros:
Fast insertions/removals anywhere (O(1) if iterator known)
Stable pointers/iterators (never invalidated unless deleted)
Cons:
No random access (O(n))
Higher memory overhead (extra pointers per node)
Poor cache performance
Use When: You need constant time insert/erase in the middle.
4. std::forward_list (Singly Linked List)
Pros:
Lower memory overhead than list
Good for memory-efficient linear processing
Cons:
Only forward traversal
No size(), no reverse iterators
Use When: Lightweight list with one-directional traversal is enough.

5. std::set / std::multiset
Pros:
Elements always sorted
Fast lookup/insertion/removal (O(log n))
Cons:
No duplicate keys in set (allowed in multiset)
Slower than unordered counterparts for lookup
No random access
Use When: Sorted order is important and duplicates may (or may not) be allowed.
6. std::map / std::multimap
Pros:
Key-value storage with ordering
Efficient ordered traversal
Cons:
Slower than unordered_map for lookup
Multimap allows duplicate keys
Use When: You need ordered key-value pairs or range queries.


7. std::unordered_set / std::unordered_multiset
Pros:
Fast average lookup, insertion, deletion (O(1) average)
Cons:
No ordering
Worst case: O(n) if many hash collisions
Requires good hash function
Use When: You need fast membership testing and don’t care about order.
8. std::unordered_map / std::unordered_multimap
Pros:
Fast key-based lookup (O(1) average)
More efficient than map when ordering isn’t needed
Cons:
No sorted order
Iteration order is undefined
Use When: You need a hash map and don't care about key order.





https://www.quantstart.com/articles/C-Standard-Template-Library-Part-III-Algorithms


Stored in header file <algorithm>

Used for processing elements of a container. 
STL algorithms are implemented as template functions and they operate with iterators.
Stored in header file <algorithm>
These algorithms may or may not modify the value/order of the elements in the container
Classification:
Non-modifying Algorithms – find(), search(), count()
Modifying Algorithms – replace(), copy(), merge()
Removing – remove(), unique()
Mutating – reverse(), partition(), rotate()
Sorting – sort(), partial_sort, stable_sort
Sorted Range – merge(), binary_search(), set_union
Numeric – inner_product(), partial_sum(), accumulate()



To use these algorithms it is necessary to include the <algorithm> header file. For the numeric algorithms, it is necessary to include the <numeric> header file.  Categories are:

Nonmodifying algorithms - Nonmodifying algorithms do not change the value of any element, nor do they modify the order in which the elements appear. 
Modifying algorithms - Modifying algorithms are designed to alter the value of elements within a container. 
Removal algorithms - Removal algorithms are, by definition, modifying algorithms, but they are designed to remove elements in a container or when copying into another container.
Mutating algorithms - Once again, mutating algorithms are modifying algorithms, but they are designed specifically to modify the order of elements (e.g. a random shuffle or rotation).
Sorting algorithms - Sorting algorithms are modifying algorithms specifically designed for efficient sorting of elements in a container (or into a range container).
Sorted range algorithms - Sorted range algorithms are special sorting algorithms designed to function on a container which is already sorted according to a particular sorting criterion. This allows for greater efficiency.
Numeric algorithms - Numeric algorithms are designed to work on numerical data in some fashion. The principal algorithm in this category is accumulate(), which allows mathematical operators to be applied to all elements in a container.



Nonmodifying Algorithms
for_each() 
count() 
count_if() 
min_element() 
max_element() 
find() 
find_if() 
search_n() 
search() 
find_end()
find_first_of() 
adjacent_find() 
equal()
mismatch() 
lexicographical_compare()





#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(int argc, char ** argv){
    vector<int> v;

   v.push_back( 23 );
   v.push_back( -1 );
   v.push_back( 9999 );
   v.push_back( 0 );
   v.push_back( 4 ); 

   cout << "Vector element: \n ";
   for(int iCt = 0; iCt< v.size(); iCt++ ){ 
    	 cout << v[iCt] << "  ";  
    } 
//To find max element
   vector<int>::iterator  iMax;
   iMax = max_element(v.begin(), v.end() );
   cout<<"\n Max element : "<<*iMax;

// To sort vector elements
   sort( v.begin(), v.end() );
 
   cout << "After sorting: ";
   for(int  iCt = 0; iCt < v.size(); iCt++ ) 
              cout << v[iCt] << "  ";  
 
// To search an element
   if(binary_search( v.begin(), v.end(), 4 ) )
	cout<<"\n Exists !!!"<<endl; 
   else
	cout<<"\n Not Exist !!!"<<endl;
return 0;
}






#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
#include <iterator>

int main() {
    std::vector<int> vec = { 1, 2, 3, 4, 2, 5, 2, 6, 7, 2 };

    // for_each
    std::cout << "for_each: ";
    std::for_each(vec.begin(), vec.end(), [](int x) {
        std::cout << x << " ";
        });
    std::cout << "\n";

    // count
    int count2 = std::count(vec.begin(), vec.end(), 2);
    std::cout << "count of 2: " << count2 << "\n";

    // count_if
    int countEven = std::count_if(vec.begin(), vec.end(), [](int x) { return x % 2 == 0; });
    std::cout << "count of even numbers: " << countEven << "\n";

    // min_element
    auto minIt = std::min_element(vec.begin(), vec.end());
    std::cout << "min_element: " << *minIt << "\n";

    // max_element
    auto maxIt = std::max_element(vec.begin(), vec.end());
    std::cout << "max_element: " << *maxIt << "\n";

    // find
    auto find5 = std::find(vec.begin(), vec.end(), 5);
    std::cout << "find 5: " << (find5 != vec.end() ? "Found\n" : "Not Found\n");

    // find_if
    auto find_gt5 = std::find_if(vec.begin(), vec.end(), [](int x) { return x > 5; });
    std::cout << "first element > 5: " << *find_gt5 << "\n";

    // search_n
    auto search2x3 = std::search_n(vec.begin(), vec.end(), 3, 2); // 3 consecutive 2s
    std::cout << "search_n (three 2s): ";
    if (search2x3 != vec.end()) std::cout << "Found at index " << std::distance(vec.begin(), search2x3) << "\n";
    else std::cout << "Not Found\n";

    // search
    std::vector<int> subsequence = { 2, 5, 2 };
    auto it = std::search(vec.begin(), vec.end(), subsequence.begin(), subsequence.end());
    std::cout << "search {2,5,2}: ";
    if (it != vec.end()) std::cout << "Found at index " << std::distance(vec.begin(), it) << "\n";
    else std::cout << "Not Found\n";

    // find_end
    auto lastMatch = std::find_end(vec.begin(), vec.end(), subsequence.begin(), subsequence.end());
    std::cout << "find_end {2,5,2}: ";
    if (lastMatch != vec.end()) std::cout << "Found at index " << std::distance(vec.begin(), lastMatch) << "\n";
    else std::cout << "Not Found\n";

    // find_first_of
    std::vector<int> targets = { 4, 7 };
    auto firstOf = std::find_first_of(vec.begin(), vec.end(), targets.begin(), targets.end());
    std::cout << "find_first_of {4,7}: " << *firstOf << " at index " << std::distance(vec.begin(), firstOf) << "\n";

    // adjacent_find
    std::vector<int> vec2 = { 1, 2, 3, 3, 4 };
    auto adj = std::adjacent_find(vec2.begin(), vec2.end());
    std::cout << "adjacent_find: ";
    if (adj != vec2.end()) std::cout << *adj << " and " << *(adj + 1) << " at index " << std::distance(vec2.begin(), adj) << "\n";
    else std::cout << "No adjacent equal elements\n";

    // equal
    std::vector<int> vec3 = { 1, 2, 3, 4, 5 };
    std::vector<int> vec4 = { 1, 2, 3, 4, 5 };
    std::cout << "equal: " << (std::equal(vec3.begin(), vec3.end(), vec4.begin()) ? "True\n" : "False\n");

    // mismatch
    std::vector<int> vec5 = { 1, 2, 0, 4, 5 };
    auto mismatchPair = std::mismatch(vec3.begin(), vec3.end(), vec5.begin());
    std::cout << "mismatch: " << *mismatchPair.first << " != " << *mismatchPair.second << "\n";

    // lexicographical_compare
    std::vector<int> a = { 1, 2, 3 };
    std::vector<int> b = { 1, 2, 4 };
    std::cout << "lexicographical_compare: " << (std::lexicographical_compare(a.begin(), a.end(), b.begin(), b.end()) ? "True\n" : "False\n");

    return 0;
}




Modifying Algorithms
for_each() 
copy() 
copy_backward()
transform()
merge() 
swap_ranges() 
fill() 
fill_n() 
generate_n() 
replace() 
replace_if()
replace_copy()
replace_copy_if()




#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>      // for iota
#include <iterator>     // for back_inserter
#include <cstdlib>      // for rand

int main() {
    std::vector<int> v1(5);
    std::iota(v1.begin(), v1.end(), 1); // v1 = {1, 2, 3, 4, 5}

    std::cout << "Original v1: ";
    std::for_each(v1.begin(), v1.end(), [](int n) { std::cout << n << " "; });
    std::cout << "\n";

    // copy
    std::vector<int> v2(5);
    std::copy(v1.begin(), v1.end(), v2.begin());

    // copy_backward
    std::vector<int> v3(7, 0); // extra space at front
    std::copy_backward(v1.begin(), v1.end(), v3.end()); // v3 = {0, 0, 1, 2, 3, 4, 5}

    // transform: double each element
    std::vector<int> v4;
    std::transform(v1.begin(), v1.end(), std::back_inserter(v4), [](int n) { return n * 2; }); // v4 = {2, 4, 6, 8, 10}

    // merge two sorted vectors
    std::vector<int> v5 = { 1, 3, 5 };
    std::vector<int> v6 = { 2, 4, 6 };
    std::vector<int> merged;
    std::merge(v5.begin(), v5.end(), v6.begin(), v6.end(), std::back_inserter(merged)); // merged = {1,2,3,4,5,6}

    // swap_ranges
    std::vector<int> v7 = { 10, 20, 30, 40, 50 };
    std::swap_ranges(v1.begin(), v1.end(), v7.begin()); // v1 = {10,20,30,40,50}, v7 = {1,2,3,4,5}

    // fill
    std::vector<int> v8(5);
    std::fill(v8.begin(), v8.end(), 7); // v8 = {7,7,7,7,7}

    // fill_n
    std::fill_n(v8.begin(), 3, 9); // v8 = {9,9,9,7,7}

    // generate_n
    std::vector<int> v9(5);
    int seed = 1;
    std::generate_n(v9.begin(), 5, [&seed]() { return seed++ * 2; }); // v9 = {2,4,6,8,10}

    // replace
    std::vector<int> v10 = { 1, 2, 2, 3, 2 };
    std::replace(v10.begin(), v10.end(), 2, 99); // v10 = {1, 99, 99, 3, 99}

    // replace_if
    std::replace_if(v10.begin(), v10.end(), [](int n) { return n > 90; }, 42); // v10 = {1, 42, 42, 3, 42}

    // replace_copy
    std::vector<int> v11;
    std::replace_copy(v1.begin(), v1.end(), std::back_inserter(v11), 40, 400); // replaces 40 in copy

    // replace_copy_if
    std::vector<int> v12;
    std::replace_copy_if(v1.begin(), v1.end(), std::back_inserter(v12), [](int n) { return n > 30; }, 300);

    // Print final vectors
    std::cout << "\nv1 after swap: ";
    for (int n : v1) std::cout << n << " ";

    std::cout << "\nv3 (copy_backward): ";
    for (int n : v3) std::cout << n << " ";

    std::cout << "\nv4 (transformed): ";
    for (int n : v4) std::cout << n << " ";

    std::cout << "\nmerged: ";
    for (int n : merged) std::cout << n << " ";

    std::cout << "\nv7 after swap: ";
    for (int n : v7) std::cout << n << " ";

    std::cout << "\nv8 (fill and fill_n): ";
    for (int n : v8) std::cout << n << " ";

    std::cout << "\nv9 (generate_n): ";
    for (int n : v9) std::cout << n << " ";

    std::cout << "\nv10 (replace + replace_if): ";
    for (int n : v10) std::cout << n << " ";

    std::cout << "\nv11 (replace_copy): ";
    for (int n : v11) std::cout << n << " ";

    std::cout << "\nv12 (replace_copy_if): ";
    for (int n : v12) std::cout << n << " ";

    return 0;
}




























