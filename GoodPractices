Here’s a solid overview of best practices for cross-platform binary compatibility in C++, especially useful if you’re distributing libraries (static .lib / .a or dynamic .dll / .so) across different platforms like Windows, Linux, and macOS.
1. Use a Stable ABI (Application Binary Interface)
ABI defines how your compiled code interacts at the binary level:
Function calling conventions
Name mangling
Data structure layout
Object file format
Tip:
Avoid compiler-specific extensions unless guarded by #ifdef.
Use extern "C" for C-style exports to prevent name mangling differences.
Example:
extern "C" int add(int a, int b); // ABI stable across compilers

2. Keep Compiler & Standard Library Consistency
Different compilers and versions often generate incompatible binaries.
Best practice:
Document the compiler and STL version your library was built with.
Avoid mixing code compiled with different compiler vendors for the same binary.
On Windows, MSVC binaries may not link with MinGW or Clang binaries without adjustments.
3. Use Fixed-Width Integer Types
Avoid platform-dependent types like long (size differs between Win64 and Linux).
Prefer:
#include <cstdint>
int32_t, int64_t, uint32_t
Ensures data structure layout consistency.

4. Avoid Exposing STL Types in Public APIs
STL containers (like std::string, std::vector) may have different memory layouts across compiler versions or even between debug and release builds.
Solution: Use PImpl (Pointer-to-Implementation) idiom to hide implementation details.
Example (PImpl):
// MyClass.h
class MyClass {
public:
    MyClass();
    ~MyClass();
    void process();
private:
    struct Impl;     // forward declaration
    Impl* pImpl;     // pointer to hidden implementation
};
5. Beware of Structure Padding & Alignment
Structure layout can vary between platforms.
Use:
#pragma pack(push, 1)  // pack without padding
struct Data { char a; int b; };
#pragma pack(pop)
Or static_assert(sizeof(Data) == expected_size); for safety.
6. Avoid Exceptions Across Library Boundaries
Exception handling mechanisms differ between compilers and runtimes.
Either:
Catch exceptions inside the library and return error codes.
Or enforce consistent exception ABI settings across builds.



7. Symbol Exporting/Importing
On Windows:
#ifdef BUILD_DLL
#define API __declspec(dllexport)
#else
#define API __declspec(dllimport)
#endif
On Linux/macOS:
#define API __attribute__((visibility("default")))
Always hide unnecessary internal symbols.
8. Avoid RTTI & Virtual Functions Across Boundaries
dynamic_cast and virtual tables may differ between compilers.
If polymorphism is needed, ensure both caller and library are built with the same compiler and RTTI settings.

9. Be Careful with Inline Functions
If inlined code changes between versions, old binaries may break without recompilation.
Keep inline functions in headers and maintain backward compatibility.
10. Use Versioned Namespaces
Helps when releasing new versions without breaking older code.
namespace mylib_v1 { /* ... */ }
11. Testing Across Platforms
Use CI pipelines with Windows, Linux, and macOS builds.
Test with different compilers: MSVC, GCC, Clang.
Keep a binary compatibility test suite.


In short:
Hide implementation details (PImpl).
Keep ABI stable (avoid STL in APIs, fixed-width types).
Use consistent compilers & settings.
Export/import symbols carefully.
Test on all target platforms regularly.








