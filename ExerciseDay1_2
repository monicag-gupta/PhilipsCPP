Exercise: Employee Management System (Console-Based) using Modern C++:

Objective:
Design a simple employee management system in modern C++ that demonstrates the use of:
auto type deduction
nullptr
enum class 
range-based for loop
smart pointers 
lambda expressions 
move semantics 


Step 1: Define a Department using enum class
Use enum class Department { HR, Finance, Engineering, Marketing };


Step 2: Create an Employee class
Attributes: ID, Name, Department, Salary
Add constructor, getters, and a print() method


Step 3: Store Employees in a vector using smart pointers
Use std::unique_ptr<Employee>

(Create a Vector for the Employees)

Step 4: Populate the vector using std::make_unique<>

(Add a few employees to the system)

Step 5: Display all employees using range-based for and auto

Step 6: Use lambda to sort employees by salary 
Step 7: Demonstrate move semantics:
Move an employee from one list to another 













Exercise: Extend your Employee Management System in Modern C++ : STL:

Objective Recap:
You’ve already implemented:
enum class, unique_ptr, auto, nullptr, range-based for, lambda, and move semantics.

Extension Objectives:
Add the following:
STL Containers: set, map, unordered_map, multimap, multiset
Iterators: begin(), end(), advance(), next(), prev(), reverse iterators
Algorithms: find_if(), count_if(), sort(), transform(), accumulate(), partition(), for_each()

Suggested Steps with Code:

Step 1: Use std::map<int, Employee*> to index employees by ID
std::map<int, Employee*> employeeIndex;
for (const auto& emp : employees) {
    employeeIndex[emp->getID()] = emp.get();  // raw pointer for demo purpose
}

Step 2: Search using find_if() by Department
auto it = std::find_if(employees.begin(), employees.end(), [](const auto& emp) {
    return emp->getDepartment() == Department::Engineering;
});
if (it != employees.end())
    std::cout << "Engineering Employee: "; (*it)->print();

Step 3: Count Employees with Salary > 50000 using count_if()
int countHighEarners = std::count_if(employees.begin(), employees.end(), [](const auto& emp) {
    return emp->getSalary() > 50000;
});
std::cout << "High earning employees: " << countHighEarners << std::endl;

Step 4: Use std::transform() to give salary hike to all
std::for_each(employees.begin(), employees.end(), [](auto& emp) {
    emp->setSalary(emp->getSalary() * 1.10);  // 10% hike
});

Step 5: Display all Employees using Reverse Iterators
for (auto it = employees.rbegin(); it != employees.rend(); ++it) {
    (*it)->print();
}

Step 6: Use std::partition() to separate high earners
auto mid = std::partition(employees.begin(), employees.end(), [](const auto& emp) {
    return emp->getSalary() > 60000;
});
std::cout << "High Earners:\n";
std::for_each(employees.begin(), mid, [](const auto& emp) { emp->print(); });

Step 7: Use std::accumulate() to calculate total payroll
double totalSalary = std::accumulate(employees.begin(), employees.end(), 0.0, [](double sum, const auto& emp) {
    return sum + emp->getSalary();
});
std::cout << "Total Payroll: " << totalSalary << std::endl;

Step 8: Use std::set to store unique departments
std::set<Department> departments;
for (const auto& emp : employees) {
    departments.insert(emp->getDepartment());
}

Step 9: Use std::multimap for grouping employees by department
std::multimap<Department, std::string> deptMap;
for (const auto& emp : employees) {
    deptMap.insert({ emp->getDepartment(), emp->getName() });
}
std::cout << "Employees Grouped by Department:\n";
for (const auto& [dept, name] : deptMap) {
    std::cout << static_cast<int>(dept) << ": " << name << std::endl;
}

Step 10: Use Iterators explicitly to display names
std::cout << "Employee Names:\n";
for (auto it = employees.begin(); it != employees.end(); ++it) {
    std::cout << (*it)->getName() << std::endl;
}

Step 11: Store sorted salaries in std::vector using transform()
std::vector<double> salaries;
std::transform(employees.begin(), employees.end(), std::back_inserter(salaries), [](const auto& emp) {
    return emp->getSalary();
});
std::sort(salaries.begin(), salaries.end());









Goal: Add Design Patterns to Your Employee Management System
Design Patterns to Implement:
Strategy Pattern – Flexible sorting or payroll computation strategies
Observer Pattern – Notify HR when high-salary employees are added
Factory Pattern – Encapsulate employee creation logic
Singleton Pattern – Central payroll manager or configuration
Visitor Pattern – Perform operations like bonus distribution, tax deduction, etc.
1. Strategy Pattern
Goal:
Dynamically choose sorting strategy (by name, by salary, etc.) at runtime.
Step:
Define a strategy interface.
Implement multiple strategies.
Inject the strategy dynamically.

2. Observer Pattern
Goal:
Notify HR or logger when high-salary employee is added.

Step:
Create Observer interface and concrete observer (e.g., HRLogger).

Subject class is EmployeeManager.

3. Factory Pattern
Goal:
Encapsulate creation of different types of Employees.

Step:
Create abstract factory method and concrete types.

4. Singleton Pattern
Goal:
Ensure one central PayrollManager exists.

Step:
Private constructor + static getInstance method.

5. Visitor Pattern
Goal:
Apply operations like bonus or tax without modifying Employee.

Step:
Define Visitor interface and concrete visitors.

