#include <iostream>
#include <string>

class Student {
private:
    std::string name;
    int marks1;
    int marks2;

public:
    // Constructor
    Student(const std::string& name, int marks1, int marks2)
        : name(name), marks1(marks1), marks2(marks2) {}

    // 1. Responsible for printing student details (Presentation logic)
    void printDetails() const {
        std::cout << "Name: " << name << std::endl;
        std::cout << "Marks1: " << marks1 << std::endl;
        std::cout << "Marks2: " << marks2 << std::endl;
    }

    // 2. Responsible for calculating percentage (Business logic)
    void calculatePercentage() const {
        double percentage = (marks1 + marks2) / 2.0;
        std::cout << "Percentage: " << percentage << "%" << std::endl;
    }

    // 3. Responsible for adding a student (Persistence logic)
    void addStudent() const {
        // Simulating saving to a database
        std::cout << "Student " << name << " added to the database." << std::endl;
    }
};

// Example usage
int main() {
    Student s("Alice", 85, 90);
    s.printDetails();
    s.calculatePercentage();
    s.addStudent();

    return 0;
}






#include <iostream>
#include <string>
#include <memory>

// 1. Data class - Single Responsibility: Store Student Data
class Student {
private:
    std::string name;
    int marks1;
    int marks2;

public:
    Student(const std::string& name, int m1, int m2)
        : name(name), marks1(m1), marks2(m2) {
    }

    std::string getName() const { return name; }
    int getMarks1() const { return marks1; }
    int getMarks2() const { return marks2; }
};

// 2. Printer class - Single Responsibility: Presentation
class StudentPrinter {
public:
    void printDetails(const Student& student) const {
        std::cout << "Name: " << student.getName() << "\n";
        std::cout << "Marks1: " << student.getMarks1() << "\n";
        std::cout << "Marks2: " << student.getMarks2() << "\n";
    }
};

// 3. Calculator class - Single Responsibility: Business logic
class StudentCalculator {
public:
    double calculatePercentage(const Student& student) const {
        return (student.getMarks1() + student.getMarks2()) / 2.0;
    }
};

// 4. Repository class - Single Responsibility: Persistence
class StudentRepository {
public:
    void addStudent(const Student& student) const {
        // Simulate saving to database
        std::cout << "Student " << student.getName() << " added to database.\n";
    }
};

// ---- Example usage ----
int main() {
    Student student("John Doe", 80, 90);

    StudentPrinter printer;
    StudentCalculator calculator;
    StudentRepository repository;

    printer.printDetails(student);
    std::cout << "Percentage: " << calculator.calculatePercentage(student) << "%\n";
    repository.addStudent(student);

    return 0;
}







#include <iostream>
#include <memory>

class Vehicle {
public:
    virtual double getNumber() const = 0;
    virtual ~Vehicle() = default;
};

class Car : public Vehicle {
public:
    double getNumber() const override {
        return 1234;
    }
};

class Bike : public Vehicle {
public:
    double getNumber() const override {
        return 5678;
    }
};

class VehicleInfo {
public:
    double vehicleNumber(std::shared_ptr<Vehicle> vcl) {
        // Not in OCP - requires modification to add support for new vehicle types
        if (dynamic_cast<Car*>(vcl.get())) {
            return vcl->getNumber();
        }
        if (dynamic_cast<Bike*>(vcl.get())) {
            return vcl->getNumber();
        }
        return -1; // default case
    }
};

int main() {
    std::shared_ptr<Vehicle> car = std::make_shared<Car>();
    std::shared_ptr<Vehicle> bike = std::make_shared<Bike>();

    VehicleInfo info;
    std::cout << "Car Number: " << info.vehicleNumber(car) << std::endl;
    std::cout << "Bike Number: " << info.vehicleNumber(bike) << std::endl;

    return 0;
}





#include <iostream>
#include <memory>
#include <vector>

// Base class (open for extension)
class Vehicle {
public:
    virtual double getNumber() const = 0;
    virtual ~Vehicle() = default;
};

// Concrete classes (new types can be added without changing existing code)
class Car : public Vehicle {
public:
    double getNumber() const override {
        return 1234;
    }
};

class Bike : public Vehicle {
public:
    double getNumber() const override {
        return 5678;
    }
};

// VehicleInfo doesn't care what kind of Vehicle it is
class VehicleInfo {
public:
    double vehicleNumber(const Vehicle& vcl) {
        return vcl.getNumber();
    }
};

int main() {
    VehicleInfo info;

    // Create various vehicles
    std::vector<std::shared_ptr<Vehicle>> vehicles = {
        std::make_shared<Car>(),
        std::make_shared<Bike>()
    };

    // Display vehicle numbers
    for (const auto& v : vehicles) {
        std::cout << "Vehicle Number: " << info.vehicleNumber(*v) << std::endl;
    }

    return 0;
}






#include <iostream>
#include <vector>
#include <memory>
#include <stdexcept>

class Bird {
public:
    virtual void fly() {
        std::cout << "Bird is flying" << std::endl;
    }

    virtual void eat() {
        std::cout << "Bird is eating" << std::endl;
    }

    virtual ~Bird() = default;
};

class Crow : public Bird {
public:
    void fly() override {
        std::cout << "Crow is flying" << std::endl;
    }

    void eat() override {
        std::cout << "Crow is eating" << std::endl;
    }
};

class Ostrich : public Bird {
public:
    void fly() override {
        // Violation: Ostrich can't fly but is forced to implement it.
        throw std::runtime_error("Ostrich can't fly!");
    }

    void eat() override {
        std::cout << "Ostrich is eating" << std::endl;
    }
};

void letTheBirdsFly(const std::vector<std::shared_ptr<Bird>>& birds) {
    for (const auto& bird : birds) {
        bird->fly(); // Will throw error for Ostrich
    }
}

int main() {
    std::vector<std::shared_ptr<Bird>> birds;
    birds.push_back(std::make_shared<Bird>());
    birds.push_back(std::make_shared<Crow>());
    birds.push_back(std::make_shared<Ostrich>()); // Not substitutable for Bird in flying

    try {
        letTheBirdsFly(birds);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }

    return 0;
}







#include <iostream>
#include <vector>
#include <memory>

class Bird {
public:
    virtual void eat() const {
        std::cout << "Bird is eating.\n";
    }

    virtual ~Bird() = default;
};

// Interface for flying behavior
class IFlyable {
public:
    virtual void fly() const = 0;
    virtual ~IFlyable() = default;
};

class Crow : public Bird, public IFlyable {
public:
    void fly() const override {
        std::cout << "Crow is flying.\n";
    }

    void eat() const override {
        std::cout << "Crow is eating.\n";
    }
};

class Ostrich : public Bird {
public:
    void eat() const override {
        std::cout << "Ostrich is eating.\n";
    }

    // No fly() here â€” does not implement IFlyable
};

void letTheBirdsFly(const std::vector<std::shared_ptr<IFlyable>>& flyingBirds) {
    for (const auto& b : flyingBirds) {
        b->fly();
    }
}

int main() {
    std::vector<std::shared_ptr<IFlyable>> flyingBirds;
    flyingBirds.push_back(std::make_shared<Crow>());

    std::cout << "--- Flying Birds ---\n";
    letTheBirdsFly(flyingBirds);

    std::vector<std::shared_ptr<Bird>> allBirds;
    allBirds.push_back(std::make_shared<Crow>());
    allBirds.push_back(std::make_shared<Ostrich>());

    std::cout << "\n--- All Birds Eating ---\n";
    for (const auto& bird : allBirds) {
        bird->eat();
    }

    return 0;
}






// Conversion.cpp

#include <iostream>

class Conversion {
public:
    virtual void intToDouble() = 0;
    virtual void intToChar() = 0;
    virtual void charToString() = 0;
    virtual ~Conversion() = default;
};

class IntConversion : public Conversion {
public:
    void intToDouble() override {
        std::cout << "intToDouble logic\n";
    }

    void intToChar() override {
        std::cout << "intToChar logic\n";
    }

    void charToString() override {
        // Not applicable, but forced to implement
        std::cout << "charToString() not supported in IntConversion\n";
    }
};

class CharConversion : public Conversion {
public:
    void intToDouble() override {
        // Not applicable, but forced to implement
        std::cout << "intToDouble() not supported in CharConversion\n";
    }

    void intToChar() override {
        // Not applicable
        std::cout << "intToChar() not supported in CharConversion\n";
    }

    void charToString() override {
        std::cout << "charToString logic\n";
    }
};

int main() {
    IntConversion intConv;
    CharConversion charConv;

    intConv.intToDouble();
    intConv.charToString();  // Forced implementation

    charConv.charToString();
    charConv.intToDouble();  // Forced implementation

    return 0;
}





#include <iostream>

// Segregated Interfaces
class IIntToDouble {
public:
    virtual void intToDouble() = 0;
    virtual ~IIntToDouble() = default;
};

class IIntToChar {
public:
    virtual void intToChar() = 0;
    virtual ~IIntToChar() = default;
};

class ICharToString {
public:
    virtual void charToString() = 0;
    virtual ~ICharToString() = default;
};

// Implements only what's needed
class IntConversion : public IIntToDouble, public IIntToChar {
public:
    void intToDouble() override {
        std::cout << "Converting int to double\n";
    }

    void intToChar() override {
        std::cout << "Converting int to char\n";
    }
};

// Implements only what's needed
class CharConversion : public ICharToString {
public:
    void charToString() override {
        std::cout << "Converting char to string\n";
    }
};

int main() {
    IntConversion intConv;
    CharConversion charConv;

    intConv.intToDouble();
    intConv.intToChar();

    charConv.charToString();

    return 0;
}






#include <iostream>

class BackEndDeveloper {
public:
    void writeJava() {
        std::cout << "Writing Java code...\n";
    }
};

class FrontEndDeveloper {
public:
    void writeJavascript() {
        std::cout << "Writing JavaScript code...\n";
    }
};

class Project {
private:
    BackEndDeveloper backendDev;
    FrontEndDeveloper frontendDev;

public:
    void implement() {
        backendDev.writeJava();
        frontendDev.writeJavascript();
    }
};

int main() {
    Project project;
    project.implement();
    return 0;
}







#include <iostream>
#include <vector>
#include <memory>

// Abstraction
class IDeveloper {
public:
    virtual void develop() = 0;
    virtual ~IDeveloper() = default;
};

// Low-level module 1
class BackEndDeveloper : public IDeveloper {
public:
    void develop() override {
        std::cout << "Writing Java code...\n";
    }
};

// Low-level module 2
class FrontEndDeveloper : public IDeveloper {
public:
    void develop() override {
        std::cout << "Writing JavaScript code...\n";
    }
};

// High-level module
class Project {
private:
    std::vector<std::shared_ptr<IDeveloper>> developers;

public:
    void addDeveloper(const std::shared_ptr<IDeveloper>& dev) {
        developers.push_back(dev);
    }

    void implement() {
        for (const auto& dev : developers) {
            dev->develop();
        }
    }
};

// Main
int main() {
    std::shared_ptr<IDeveloper> backend = std::make_shared<BackEndDeveloper>();
    std::shared_ptr<IDeveloper> frontend = std::make_shared<FrontEndDeveloper>();

    Project project;
    project.addDeveloper(backend);
    project.addDeveloper(frontend);

    project.implement();

    return 0;
}








