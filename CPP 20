Modern syntax and language improvements

Here are some modern syntax and language improvements in C++, highlighting how the language has evolved from C++11 to C++20/23. This includes concise syntax, new features, and developer-friendly improvements.
1. Type Inference with auto (C++11)
Avoids redundant types, improves readability.
auto x = 42;       // int
auto pi = 3.14;    // double
auto name = "Jay"; // const char*
2. Range-Based for Loop (C++11)
Simplifies iteration.
std::vector<int> v = {1, 2, 3};
for (auto n : v)
    std::cout << n << " ";
3. Uniform Initialization {} (C++11+)
Safer and more consistent initialization syntax.
int x{10};                  // direct init
std::vector<int> v{1, 2, 3}; // list init


4. Lambda Expressions (C++11, C++14, C++20)
Compact anonymous functions.
auto add = [](int a, int b) { return a + b; };
std::cout << add(3, 4);
C++14/20: Generic lambdas
auto square = [](auto x) { return x * x; };
std::cout << square(5); // 25
5. Smart Pointers (unique_ptr, shared_ptr) (C++11)
Automatic memory management.
std::unique_ptr<int> p = std::make_unique<int>(10);
6. nullptr Instead of NULL (C++11)
Type-safe null pointer constant.
int* p = nullptr;
7. Move Semantics and std::move (C++11)
Efficient resource transfer.
std::string a = "Hello";
std::string b = std::move(a); // a is now empty


8. constexpr (C++11 â†’ C++20)
Compile-time constants and functions.
constexpr int square(int x) { return x * x; }
int result = square(5);
9. Structured Bindings (C++17)
Decompose structs, tuples.
std::tuple<int, std::string, double> t = {1, "John Doe", 10.9};
auto [id, name, sal] = t;
10. if constexpr (C++17)
Compile-time if, eliminates dead code.
template<typename T>
void print(T t) {
    if constexpr (std::is_integral_v<T>)
        std::cout << "int: " << t;
    else
        std::cout << "not int";
}



11. std::optional, std::variant, std::any (C++17)
Handle absence or multiple types.
std::optional<int> maybeInt = 5;
if (maybeInt) std::cout << *maybeInt;
12. std::string_view (C++17)
Non-owning string reference (fast, safe).
void greet(std::string_view name) {
    std::cout << "Hello, " << name;
}
13. [[nodiscard]], [[maybe_unused]], Attributes (C++17+)
Code correctness hints to compiler.
[[nodiscard]] int compute();  // warn if result is ignored
14. Concepts and requires (C++20)
Constrain templates with readable conditions.
template<typename T>
concept Integral = std::is_integral_v<T>;
template<Integral T>
T add(T a, T b) { return a + b; }

15. consteval and constinit (C++20)
Force compile-time evaluation or initialization.
consteval int ten() { return 10; }  // must evaluate at compile-time
constinit int global = ten();       // must be initialized at compile-time
16. Coroutines (C++20)
Lazy generators and async programming.
generator<int> range(int n) {
    for (int i = 0; i < n; ++i)
        co_yield i;
}
17. Calendar and Timezones <chrono> (C++20)
Modern time and date APIs.
auto now = std::chrono::system_clock::now();
auto today = std::chrono::floor<std::chrono::days>(now);

18. Modules (C++20) (replaces headers)
Faster compile times and cleaner code organization.
// mymath.ixx
export module mymath;
export int add(int a, int b) { return a + b; }
// main.cpp
import mymath;
std::cout << add(2, 3);
19. std::format for String Formatting (C++20)
Python-style formatting.
std::cout << std::format("Value: {:.2f}", 3.1415);  // Value: 3.14























