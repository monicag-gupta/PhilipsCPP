RAII in C++ (Resource Acquisition Is Initialization):

RAII is a core C++ idiom that ties the lifetime of resources (like memory, files, sockets, locks) to the lifetime of objects. 
It ensures that resources are acquired during object construction and released during object destruction, automatically and safely.
Key Principle
"Bind a resource's lifetime to an object's lifetime."
When an RAII object goes out of scope (or is deleted), its destructor is automatically called, and the resource is released ‚Äî no need to remember to clean up manually.





#include <iostream>
class IntArray {
    int* data;    size_t size;
public:
    IntArray(size_t size) : size(size) {
        data = new int[size]; // Resource acquisition (heap memory)
       std::cout << "Memory allocated\n";
    }
    ~IntArray() {
        delete[] data; // Resource release
        std::cout << "Memory deallocated\n";        }
    void set(size_t index, int value) {
        if (index < size)
            data[index] = value;     }
    int get(size_t index) const {
        return (index < size) ? data[index] : -1;       }
};
int main() {
    {
        IntArray arr(5);
        arr.set(0, 42);
        std::cout << arr.get(0) << std::endl;  //No Manual Cleanup Required in main(). Memory is released automatically due to RAII
    }  // RAII: destructor automatically called here
}




Reading from a file data.txt
Without RAII (Manual Resource Management)


#include <iostream>
using namespace std;

void main() {
    FILE* file = nullptr;
    errno_t err = fopen_s(&file, "data.txt", "r");  
    if (err != 0 || file == nullptr) {
        cout<<("File could not be opened.\n");
        return;
    }

    char buffer[100];
    while (fgets(buffer, sizeof(buffer), file)) {
       cout<<buffer;
    }

    fclose(file);  // Closes safely
}




Pitfalls:
‚Ä¢	Must manually call fclose() ‚Äî easy to forget
‚Ä¢	If an early return or an exception occurs, file may not close
‚Ä¢	No guarantee of cleanup unless we explicitly manage every exit path



Reading from a file data.txt
With RAII (Using std::ifstream)

#include <iostream>
#include <fstream>
#include <string>

void main() {
    std::ifstream file("data.txt");  // File opened

    if (!file.is_open()) {
        std::cerr << "File could not be opened.\n";
        return;
    }

    std::string line;
    while (std::getline(file, line)) {
        std::cout << line << std::endl;
    }
}  // file is automatically closed when going out of scope




std::unique_ptr ‚Äì Exclusive Ownership

This is the recommended way to create a unique_ptr as it provides exception safety and avoids potential issues with raw new expressions.
    #include <memory> // Required header
    // Create a unique_ptr to an int, initialized with value 42
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    // Create a unique_ptr to an object of MyClass, using its default constructor
    std::unique_ptr<MyClass> obj_ptr = std::make_unique<MyClass>();
Direct Construction with new (Less Preferred).
While functional, this method is less preferred due to potential exception safety concerns if new throws an exception before the unique_ptr constructor completes.
    #include <memory> // Required header
    // Create a unique_ptr to an int, initialized with value 42
    std::unique_ptr<int> ptr(new int(42));
    // Create a unique_ptr to an object of MyClass
    std::unique_ptr<MyClass> obj_ptr(new MyClass());
Key Characteristics and Operations:
Exclusive Ownership: unique_ptr cannot be copied; ownership must be transferred using std::move.
    std::unique_ptr<int> p1 = std::make_unique<int>(10);
    std::unique_ptr<int> p2 = std::move(p1); // Transfers ownership from p1 to p2
    // p1 is now null
Accessing the Managed Object: Use * (dereference operator) or -> (member access operator).
    std::unique_ptr<int> ptr = std::make_unique<int>(5);
    int value = *ptr; // Access the integer value
    // If MyClass has a method 'do_something()'
    // std::unique_ptr<MyClass> obj_ptr = std::make_unique<MyClass>();
    // obj_ptr->do_something();

Releasing Ownership: Use release() to relinquish ownership and return the raw pointer. The caller then becomes responsible for managing the memory.
    std::unique_ptr<int> ptr = std::make_unique<int>(20);
    int* raw_ptr = ptr.release(); // ptr is now null, raw_ptr points to the int
    delete raw_ptr; // Manual deletion required
Resetting the Pointer: Use reset() to release the current resource and optionally take ownership of a new one.
    std::unique_ptr<int> ptr = std::make_unique<int>(30);
    ptr.reset(); // Releases the managed int, ptr becomes null
    ptr.reset(new int(40)); // Releases current (null) and takes ownership of new int
Custom Deleters: You can specify a custom deleter function or functor as a template argument to unique_ptr to handle resource deallocation in a specific way (e.g., closing a file handle).
    // Example with a custom deleter for FILE*
    std::unique_ptr<std::FILE, decltype(&std::fclose)> file_ptr(std::fopen("file.txt", "r"), &std::fclose);


int x;
decltype(x);   //int

fn(){..}
decltype(fn) //{..}





#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "Constructed\n"; }
    ~MyClass() { std::cout << "Destructed\n"; }
};

int main() {
    std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>();
    // MyClass is automatically destroyed here
}





std::shared_ptr ‚Äì Shared Ownership

Multiple shared_ptrs can point to the same object
Keeps a reference count
Deletes the object when the last owner is gone

When to Use:
You need multiple owners
Lifetime of object is tied to all owners


#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "Constructed\n"; }
    ~MyClass() { std::cout << "Destructed\n"; }
};

int main() {
    std::shared_ptr<MyClass> ptr1 = std::make_shared<MyClass>();
    std::shared_ptr<MyClass> ptr2 = ptr1;  // Shared ownership
    std::cout << "Reference count: " << ptr1.use_count() << "\n";
}



std::weak_ptr ‚Äì Non-Owning Reference

Observes a shared_ptr without affecting its reference count
Useful to break circular references

When to Use:
To avoid circular references (shared_ptr ‚Üí shared_ptr)
You want to check if the object is alive without owning it



#include <iostream>
#include <memory>

class MyClass {
public:
    MyClass() { std::cout << "Constructed\n"; }
    ~MyClass() { std::cout << "Destructed\n"; }
};

int main() {
    std::shared_ptr<MyClass> shared = std::make_shared<MyClass>();
    std::weak_ptr<MyClass> weak = shared;  // Doesn't extend lifetime

    std::cout << "Reference count: " << shared.use_count() << "\n";

    if (auto observed = weak.lock()) {
        std::cout << "Object is still alive.\n";
    }
}



#include <iostream>
#include <memory>

class Node {
public:
    std::shared_ptr<Node> next;  // ‚ùå shared_ptr causes circular reference
    Node() { std::cout << "Node created\n"; }
    ~Node() { std::cout << "Node destroyed\n"; }
};

int main() {
    {
        std::shared_ptr<Node> node1 = std::make_shared<Node>();
        std::shared_ptr<Node> node2 = std::make_shared<Node>();

        node1->next = node2;
        node2->next = node1;  // üîÅ Circular reference

        std::cout << "node1 use_count: " << node1.use_count() << std::endl;
        std::cout << "node2 use_count: " << node2.use_count() << std::endl;
    }
    std::cout << "Exited scope.\n";
    return 0;
}





#include <iostream>
#include <memory>

class Node {
public:
    std::weak_ptr<Node> next;  // ‚úÖ weak_ptr breaks the circular reference
    Node() { std::cout << "Node created\n"; }
    ~Node() { std::cout << "Node destroyed\n"; }
};

int main() {
    {
        std::shared_ptr<Node> node1 = std::make_shared<Node>();
        std::shared_ptr<Node> node2 = std::make_shared<Node>();
        node1->next = node2;
        node2->next = node1;  // Still circular, but non-owning
        std::cout << "node1 use_count: " << node1.use_count() << std::endl;
        std::cout << "node2 use_count: " << node2.use_count() << std::endl;
    }
    std::cout << "Exited scope.\n";
    return 0;
}






































