#include <iostream>
#include <type_traits>

template<typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is integral.\n";
}

template<typename T>
typename std::enable_if<!std::is_integral<T>::value, void>::type
print(T value) {
    std::cout << value << " is NOT integral.\n";
}

int main() {
    print(42);     // integral
    print(3.14);   // NOT integral
}









#include <iostream>
#include <typeinfo>

int main() {
    int x = 10;
    double y = 3.14;

    decltype(x) a = 5;     // 'a' is of type int
    decltype(y) b = 2.5;   // 'b' is of type double

    std::cout << typeid(a).name() << "\n"; // Usually prints "i" (int)
    std::cout << typeid(b).name() << "\n"; // Usually prints "d" (double)
}







With Expressions
decltype can deduce types from expressions:
int i = 0;
decltype(i + 2.5) result; // 'result' will be double because i + 2.5 is double
With Functions
int foo() { return 42; }
decltype(foo()) val = foo(); // val is int
Important Rule: Value Categories
decltype behaves differently based on value category:
int x = 5;
int& ref = x;
decltype(x)   a = x; // int
decltype(ref) b = x; // int&   (reference preserved)
decltype((x)) c = x; // int&   (note the extra parentheses!)
Without parentheses → you get the declared type.
With parentheses → expression form, may yield reference type.







Common Use Cases
Generic programming: deducing return types
Template metaprogramming
With auto to tie variable type to another expression’s type.

Example in templates:
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}
Here:
decltype(a + b) ensures return type matches the result of adding a and b.








#include <iostream>
#include <typeinfo>
#include <string>

int foo() { return 42; } // Example function

// Generic template function using decltype to deduce return type
template <typename T, typename U>
auto add(T a, U b) -> decltype(a + b) {
    return a + b;
}

int main() {
    std::cout << std::boolalpha;

    // 1️. With Expressions
    int i = 0;
    decltype(i + 2.5) result = i + 2.5; // double
    std::cout << "decltype(i + 2.5) -> " << typeid(result).name()
        << " value: " << result << "\n";

    // 2️. With Functions
    decltype(foo()) val = foo(); // int
    std::cout << "decltype(foo()) -> " << typeid(val).name()
        << " value: " << val << "\n";

    // 3️. Value Categories
    int x = 5;
    int& ref = x;

    decltype(x)   a = x; // int
    decltype(ref) b = x; // int& (reference preserved)
    decltype((x)) c = x; // int& (expression, yields reference)

    a = 10;
    b = 20; // changes x
    c = 30; // also changes x

    std::cout << "decltype(x) a = " << a << "\n";
    std::cout << "decltype(ref) b = " << b << "\n";
    std::cout << "decltype((x)) c = " << c << "\n";
    std::cout << "x after b and c changes: " << x << "\n";

    // 4️. Common Use Case - Templates
    auto sum1 = add(2, 3.5);         // deduced double
    auto sum2 = add(std::string("Hello, "), std::string("World!")); // deduced std::string

    std::cout << "add(2, 3.5) -> " << sum1 << " (" << typeid(sum1).name() << ")\n";
    std::cout << "add(strings) -> " << sum2 << " (" << typeid(sum2).name() << ")\n";

    return 0;
}





#include <iostream>
#include <type_traits>

template <typename T>
void printTypeInfo(T value) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << value << " is integral.\n";
    }
    else if constexpr (std::is_floating_point_v<T>) {
        std::cout << value << " is floating point.\n";
    }
    else {
        std::cout << "Unknown type.\n";
    }
}
int main() {
    printTypeInfo(42);     // 42 is integral.
    printTypeInfo(3.14);   // 3.14 is floating point.
    printTypeInfo("Hi");   // Unknown type.
}






Concepts (C++20) are compile-time predicates that constrain template parameters.
Think of them as rules or contracts you place on a template type to ensure it meets certain requirements — before the compiler even instantiates the template.
Built-in concepts include:
std::integral, std::floating_point
std::same_as, std::convertible_to
std::derived_from
std::default_initializable, std::copyable, etc





#include <concepts>
#include <iostream>
//template<typename T>  //without concepts
//T add(T a, T b) {
//    return a + b; // error only happens if T doesn't support +
//}
template<std::integral T> // concept: only integers allowed
T add(T a, T b) {
    return a + b;
}
int main() {
    std::cout << add(2, 3) << "\n";   // works
    // std::cout << add(2.5, 3.5) << "\n"; // compile-time error: doesn't satisfy integral
}






#include <iostream>
#include <concepts> // for std::integral
// 1️. AUTO PARAMETERS (abbreviated template, no constraints)
auto add_auto(auto a, auto b) {
    return a + b; // deduced return type
}
// 2️. CLASSIC TEMPLATE (no constraints)
template<typename T, typename U>
auto add_template(T a, U b) {
    return a + b; // deduced return type
}
// 3️. CONCEPTS WITH CLASSIC TEMPLATE
template<std::integral T, std::integral U>
auto add_concept(T a, U b) {
    return a + b; // only integral types allowed
}
// 4️. AUTO PARAMETERS WITH CONCEPTS (most concise constrained form)
auto add_auto_concept(std::integral auto a, std::integral auto b) {
    return a + b; // only integral types allowed
}
int main() {
    // 1. Auto parameters
    std::cout << "add_auto: " << add_auto(3.5, 2) << "\n"; // works for any type with +
    // 2. Classic template
    std::cout << "add_template: " << add_template(5, 10) << "\n"; // any type with +
    // 3. Concepts with classic template
    std::cout << "add_concept: " << add_concept(7, 8) << "\n"; // OK: integral
    // std::cout << add_concept(3.5, 2) << "\n"; // Compile error: double not integral
    // 4. Auto parameters with concepts
    std::cout << "add_auto_concept: " << add_auto_concept(20, 30) << "\n"; // OK: integral
    // std::cout << add_auto_concept(3.5, 2) << "\n"; // Compile error
    return 0;
}

