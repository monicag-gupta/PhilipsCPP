#include<iostream>
using namespace std;
class System {
private:
    string s;
    System(string ss) { s = ss; }
public:
    static System& getInstance(string ss) {
        static System theInstance(ss);
        return theInstance;
    }
    void prn() {
        std::cout << s << " says this works!\n";
    }
};
int main() {
    System& sys1 = System::getInstance("sys1");
    sys1.prn();
    System& sys2 = System::getInstance("sys2"); //not created again
    sys2.prn();
    if (&sys1 == &sys2)
        cout << "Equal";
    else
        cout << "Not equal";
}







#include <iostream>
#include <string>
using namespace std;
class Shape {
public:
	virtual void Draw() = 0;
	static Shape* Create(string type);
};
class Circle : public Shape {
public:
	void Draw() { cout << "I am circle" << endl; }
	friend class Shape;
};
class Square : public Shape {
public:
	void Draw() { cout << "I am square" << endl; }
	friend class Shape;
};
Shape* Shape::Create(string type) {
	if (type == "circle") return new Circle();
	if (type == "square") return new Square();
	return NULL;
}
int main() {
	Shape* obj1 = Shape::Create("circle");
	Shape* obj2 = Shape::Create("square");
	obj1->Draw();
	obj2->Draw();
}




#include <iostream>	
#include <string>	
using namespace std;
class Device {
public:
	virtual void send(string data) = 0;
};
class Wifi : public Device {
public:
	void send(string data) {
		cout << "Sent By Wifi: " << data << endl;
	}
};
class Bluetooth : public Device {
public:
	void send(string data) {
		cout << "Sent By Bluetooth: " << data << endl;
	}
};
// Problem: Multiple if every function for handle the environment
// Solution: Build Abstract Factory and get method
class AbstractFactory {
public:
	virtual Device* get(int) = 0;
};
class DeviceAbstractFactory : public AbstractFactory {
public:
	Device* get(int x) {
		if (x == 1) { return new Wifi; }
		else { return new Bluetooth; }
	}
};
int main() {
	AbstractFactory* abstractFactory = new DeviceAbstractFactory;
	Device* device;		device = abstractFactory->get(2);
	device->send("Abstract Factory Design Pattern Worked.");
}







#include <iostream>
#include <memory>
#include <string>
using namespace std;

// Subject Interface
class Account {
public:
    virtual void accessAccount() = 0;
    virtual ~Account() {}
};

// Real Subject
class BankAccount : public Account {
    string owner;
public:
    BankAccount(string o) : owner(o) {}
    void accessAccount() override {
        cout << "Access granted to " << owner << "'s bank account.\n";
    }
};

// Proxy
class BankAccountProxy : public Account {
    shared_ptr<BankAccount> realAccount;
    string password;
public:
    BankAccountProxy(shared_ptr<BankAccount> acct, string pwd)
        : realAccount(acct), password(pwd) {
    }

    void accessAccount() override {
        string input;
        cout << "Enter password to access account: ";
        cin >> input;
        if (input == password) {
            realAccount->accessAccount();
        }
        else {
            cout << "Access Denied: Invalid password.\n";
        }
    }
};

// Main Client
int main() {
    shared_ptr<BankAccount> real = make_shared<BankAccount>("Alice");
    BankAccountProxy proxy(real, "1234");

    proxy.accessAccount(); // Try with 1234 or wrong password
    return 0;
}








These design patterns are all about Class's objects communication. Behavioral patterns are those patterns that are most specifically concerned with communication between objects.

Chain of responsibility
A way of passing a request between a chain of objects
Command
Encapsulate a command request as an object
Interpreter
A way to include language elements in a program
Iterator
Sequentially access the elements of a collection
Mediator
Defines simplified communication between classes
Memento
Capture and restore an object's internal state
Null Object
Designed to act as a default value of an object
Observer
A way of notifying change to a number of classes
State
Alter an object's behavior when its state changes
Strategy
Encapsulates an algorithm inside a class
Template method
Defer the exact steps of an algorithm to a subclass
Visitor
Defines a new operation to a class without change






#include <iostream>
#include <string>
class Observer {
public:
	virtual ~Observer() {}
	virtual void on_message(const std::string&) = 0;
};
class MessageBoard {
	Observer& observer;
public:
	MessageBoard(Observer& obs) : observer(obs) {}
	void post(const std::string& str) {
		observer.on_message(str);
	}
};
class Writer : public Observer {
public:
	void on_message(const std::string& str) {
		std::cout << str << std::endl;
	}
};
void hello_world(MessageBoard& message_board) {
	message_board.post("Hello world!");
}
int main() {
	Writer writer;
	MessageBoard message_board(writer);
	hello_world(message_board);
	return 0;
}





#include <iostream>
#include <vector>
#include <memory>

// Forward declaration
class Circle;
class Rectangle;

// Visitor Interface
class ShapeVisitor {
public:
    virtual void visit(Circle& c) = 0;
    virtual void visit(Rectangle& r) = 0;
    virtual ~ShapeVisitor() = default; //This tells the compiler to generate the default destructor. It behaves just like a compiler-generated destructor but explicitly defined in your code.
};

// Element Interface
class Shape {
public:
    virtual void accept(ShapeVisitor& visitor) = 0;
    virtual ~Shape() = default;
};

// Concrete Element: Circle
class Circle : public Shape {
public:
    Circle(double r) : radius(r) {}
    double getRadius() const { return radius; }
    void accept(ShapeVisitor& visitor) override {
        visitor.visit(*this);
    }
private:
    double radius;
};

// Concrete Element: Rectangle
class Rectangle : public Shape {
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    double getWidth() const { return width; }
    double getHeight() const { return height; }
    void accept(ShapeVisitor& visitor) override {
        visitor.visit(*this);
    }
private:
    double width, height;
};

// Concrete Visitor: Area Calculator
class AreaCalculator : public ShapeVisitor {
public:
    void visit(Circle& c) override {
        double area = 3.14159 * c.getRadius() * c.getRadius();
        std::cout << "Circle Area: " << area << std::endl;
    }
    void visit(Rectangle& r) override {
        double area = r.getWidth() * r.getHeight();
        std::cout << "Rectangle Area: " << area << std::endl;
    }
};

// Concrete Visitor: Description Printer
class DescriptionPrinter : public ShapeVisitor {
public:
    void visit(Circle& c) override {
        std::cout << "This is a Circle with radius " << c.getRadius() << std::endl;
    }
    void visit(Rectangle& r) override {
        std::cout << "This is a Rectangle with width " << r.getWidth()
            << " and height " << r.getHeight() << std::endl;
    }
};

// Main Function
int main() {
    std::vector<std::shared_ptr<Shape>> shapes;
    shapes.push_back(std::make_shared<Circle>(5.0));
    shapes.push_back(std::make_shared<Rectangle>(4.0, 3.0));

    AreaCalculator areaVisitor;
    DescriptionPrinter descVisitor;

    std::cout << "----Descriptions----" << std::endl;
    for (auto& shape : shapes)
        shape->accept(descVisitor);

    std::cout << "\n----Areas----" << std::endl;
    for (auto& shape : shapes)
        shape->accept(areaVisitor);

    return 0;
}







#include <iostream>
#include <vector>
#include <algorithm>
#include <memory>

// Strategy Interface
class SortStrategy {
public:
    virtual void sort(std::vector<int>& data) = 0;
    virtual ~SortStrategy() {}
};

// Concrete Strategy A: Ascending Sort
class AscendingSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::sort(data.begin(), data.end());
        std::cout << "Sorted in Ascending Order.\n";
    }
};

// Concrete Strategy B: Descending Sort
class DescendingSort : public SortStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::sort(data.begin(), data.end(), std::greater<int>());
        std::cout << "Sorted in Descending Order.\n";
    }
};

// Context Class
class SortContext {
private:
    std::unique_ptr<SortStrategy> strategy;
public:
    void setStrategy(std::unique_ptr<SortStrategy> s) {
        strategy = std::move(s);
    }

    void executeStrategy(std::vector<int>& data) {
        if (strategy)
            strategy->sort(data);
        else
            std::cout << "No strategy set!\n";
    }
};

// Helper function to print vector
void printVector(const std::vector<int>& data) {
    for (int num : data)
        std::cout << num << " ";
    std::cout << "\n";
}

int main() {
    std::vector<int> numbers = { 5, 2, 9, 1, 7 };

    SortContext context;

    std::cout << "Original data: ";
    printVector(numbers);

    context.setStrategy(std::make_unique<AscendingSort>());
    context.executeStrategy(numbers);
    printVector(numbers);

    context.setStrategy(std::make_unique<DescendingSort>());
    context.executeStrategy(numbers);
    printVector(numbers);

    return 0;
}






#include <iostream>
#include <memory>
// Forward declaration
class FanState;
// Context
class Fan {
    std::shared_ptr<FanState> state;
public:
    Fan(std::shared_ptr<FanState> initialState) : state(initialState) {}
    void setState(std::shared_ptr<FanState> newState) { state = newState; }
    void pressButton();
};
// State Interface
class FanState {
public:
    virtual void handle(Fan& fan) = 0;
    virtual ~FanState() = default;
};
// Forward declarations of concrete states (to break circular dependency)
class FanOn;
class FanOff;
// Concrete State: FanOn
class FanOn : public FanState {
public:
    void handle(Fan& fan) override;
};
// Concrete State: FanOff
class FanOff : public FanState {
public:
    void handle(Fan& fan) override;
};
// Define method after both concrete classes are known
void FanOn::handle(Fan& fan) {
    std::cout << "Fan is turning OFF\n";
    fan.setState(std::make_shared<FanOff>());
}
void FanOff::handle(Fan& fan) {
    std::cout << "Fan is turning ON\n";
    fan.setState(std::make_shared<FanOn>());
}
// Context method
void Fan::pressButton() {
    state->handle(*this);
}
// Main function
int main() {
    std::shared_ptr<FanState> initialState = std::make_shared<FanOff>();
    Fan fan(initialState);
    fan.pressButton(); // Fan is turning ON
    fan.pressButton(); // Fan is turning OFF
    fan.pressButton(); // Fan is turning ON
    return 0;
}


















