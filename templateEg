#include <iostream>
using namespace std;
template <class T>
class mypair {
    T a, b;
public:
    mypair(T first, T second)
    {
        a = first; b = second;
    }
    T getmax() {
        T retval;
        retval = a > b ? a : b;
        return retval;
    }
};
int main() {
    mypair <int> myobject(100, 75);
    cout << myobject.getmax();
    return 0;
}







#include<iostream>
using namespace std;
template<class T, class U>
class A {
	T x;
	U y;
      public:
	A() { cout << "Constructor Called" << endl; }
};
int main() {
	A<char, char> a;
	A<int, double> b;
	return 0;
}
//Exercise: tell about the datatype  of x, y by using RTTI:Constructor called with datatype: char, char : typeid(x).name()






#include<iostream>
using namespace std;
template<class T, class U = char>
class A {
    public:
	T x;
	U y;
	A() { cout << "Constructor Called" << endl; }
};
int main() {
	A<char> a;  // This will call A<char, char> 
	A<int, double> b; // This will call A<int, double> 
  
	return 0;
}









constexpr means "evaluated at compile time if possible".
It tells the compiler:
This variable / function can be evaluated at compile time.
If the arguments are all constant expressions, the result is computed during compilation.
Otherwise, it’s still valid at runtime.
constexpr with Variables
A constexpr variable must be initialized with a compile-time constant.
constexpr with Functions
A constexpr function can run:
At compile time if called with constant arguments.
At runtime if called with non-constant arguments.
constexpr Constructors and Objects
You can make constructors constexpr so that objects can be created at compile time.
constexpr enables compile-time evaluation but doesn’t force it for all calls.
Great for constants, lookup tables, and computations that don’t need to be recomputed at runtime.
Often combined with consteval in C++20 when you must compute at compile time.



#include <iostream>
#include <array>
constexpr int square(int n) { //constexpr function
    return n * n;
} 
// constexpr constructor & method
struct Point {
    int x, y;
    constexpr Point(int a, int b) : x(a), y(b) {}
    constexpr int getX() const { return x; }
};
int main() {
    // constexpr with variables
    constexpr int maxValue = 100;       // compile-time constant
    constexpr double pi = 3.14159;      // compile-time constant
    // int runtimeValue = 50;
    // constexpr int invalidConstexpr = runtimeValue; // ERROR: not known at compile time

    // constexpr with functions
    constexpr int ctSquare = square(5); // compile-time evaluation
    int num = 7;
    int rtSquare = square(num);         // runtime evaluation

    // constexpr constructors and objects
    constexpr Point p1(3, 4); // compile-time object
    Point p2(5, 6);           // runtime object

    // constexpr vs const
    const int constVar = 10;        // runtime constant (may be optimized)
    constexpr int constExprVar = 20; // compile-time constant guaranteed

    // Using constexpr in compile-time context (array size)
    std::array<int, square(4)> arr; // size = 16 at compile time

    // Output results
    std::cout << "1. Constexpr Variables: maxValue = " << maxValue << ", pi = " << pi << "\n";
    std::cout << "2️. Constexpr Functions: ctSquare (compile-time) = " << ctSquare
        << ", rtSquare (runtime) = " << rtSquare << "\n";
    std::cout << "3️. Constexpr Objects: p1.x = " << p1.getX() << ", p2.x = " << p2.getX() << "\n";
    std::cout << "4️. Const vs Constexpr: constVar = " << constVar
        << ", constExprVar = " << constExprVar << "\n";
    std::cout << "Array size using constexpr = " << arr.size() << "\n";
}








#include <iostream>
#include <array>

// -------------------- constexpr function --------------------
constexpr int square(int n) {
    return n * n;
}

// -------------------- consteval function --------------------
consteval int cube(int n) {
    return n * n * n;
}

// -------------------- constexpr constructor --------------------
struct Point {
    int x, y;
    constexpr Point(int a, int b) : x(a), y(b) {}
    constexpr int getX() const { return x; }
    constexpr int getY() const { return y; }
};

int main() {
    // -------------------- constexpr vs const variables --------------------
    constexpr int constexprVar = 42; // Compile-time constant
    const int constVar = 10;         // Runtime constant (value fixed after init)

    int num = 7; // Runtime value

    // -------------------- constexpr with functions --------------------
    constexpr int ctSquare = square(5); // Compile-time evaluation
    int rtSquare = square(num);         // Runtime evaluation (num not known at compile time)

    // -------------------- consteval function usage --------------------
    constexpr int ctCube = cube(3); // Must be compile-time
    // int runtimeCube = cube(num);  // ERROR: consteval requires compile-time

    // -------------------- constexpr constructor & objects --------------------
    constexpr Point p1(3, 4); // Compile-time object
    Point p2(5, 6);           // Runtime object

    // -------------------- constexpr usage in array size --------------------
    std::array<int, cube(2)> arr; // compile-time size (2^3 = 8)

    // -------------------- Output results --------------------
    std::cout << "=== Variables ===\n";
    std::cout << "constexprVar = " << constexprVar << "\n";
    std::cout << "constVar     = " << constVar << "\n";

    std::cout << "\n=== constexpr function square() ===\n";
    std::cout << "Compile-time square(5) = " << ctSquare << "\n";
    std::cout << "Runtime square(num=7)  = " << rtSquare << "\n";

    std::cout << "\n=== consteval function cube() ===\n";
    std::cout << "Compile-time cube(3)   = " << ctCube << "\n";
    // std::cout << "Runtime cube(num)     = " << runtimeCube << "\n"; // won't compile

    std::cout << "\n=== constexpr Objects ===\n";
    std::cout << "p1 (compile-time) X=" << p1.getX() << ", Y=" << p1.getY() << "\n";
    std::cout << "p2 (runtime)      X=" << p2.getX() << ", Y=" << p2.getY() << "\n";

    std::cout << "\n=== Array ===\n";
    std::cout << "Array size from cube(2) = " << arr.size() << "\n";
}



#include<iostream>
using namespace std;
template<typename T>
constexpr T PI = T(3.1415926535897932385);
int main()
{
    cout<<"PI:"<< PI<int><<endl;
    cout << "PI:" << PI<double> << endl;
    return 0;
}
//constexpr is compile time interference
//constexpr can be used as an expression elsewhere also; sealed or final keyword in c#/java







#include<iostream>
using namespace std;
template<typename T>
T PI = T(3.1415926535897932385);
template<typename T>
T area(T r) {
	return PI<T> * r * r;
}
int main()
{
	cout<<"PI:"<< PI<int><<"  area: "<<area(2)<<endl;
	cout << "PI:" << PI<double> << "  area: " << area(2.0) << endl;
	return 0;
}






Passing variable number of arguments

Variable number of parameters has two parts:
an int which will represent the total number variable arguments passed
And last argument as ellipses, i.e. three dotes (...) representing the variable number of parameters 
To use such functionality, you need to make use of stdarg.h header file which provides the functions and macros to implement the functionality of variable arguments:
va_list type variable representing the variable list
va_start macro to initialize the va_list variable to an argument list
va_arg macro to access each item in argument list
macro va_end to clean up the memory assigned to va_list variable




/* va_arg example */
#include <stdio.h>      /* printf */
#include <stdarg.h>     /* va_list, va_start, va_arg, va_end */

int FindMax (int n, ...)
{
  int i,val,largest=0;
  va_list vl;
  va_start(vl,n);
 // largest=va_arg(vl,int);
  for (i=0;i<n;i++)
  {
    val=va_arg(vl,int);
    largest=(largest>val)?largest:val;
  }
  va_end(vl);
  return largest;
}

int main ()
{
  int m;
  m= FindMax (7,702,422,631,834,892,104,772);
  printf ("The largest value is: %d\n",m);
  m= FindMax (3, 10, 80,35);
  printf ("The largest value is: %d\n",m);
  return 0;
}






#include<iostream>
using namespace std;
// To handle base case of below recursive
// Variadic function Template
void print()
{
	cout << "I am empty function and "
		"I am called at last.\n";
}
// Variadic function Template that takes variable number 
//of arguments and prints all of them.
template <typename T, typename... Types>
void print(T var1, Types... var2) {
	cout << var1 << endl;
	print(var2...);
}
int main() {
	print(1, 2, 3.14, "Pass me any "
		"number of arguments",
		"I will print\n");
	return 0;
}




#include<iostream>
#include<string>
using namespace std;
template<typename T>
T adder(T v) {
  return v;
}

template<typename T, typename... Args>
T adder(T first, Args... args) {
  return first + adder(args...);
}
int main() {
    long sum = adder(1, 2, 3, 8, 7);
    cout<<"sum="<<sum<<endl;
    string s1 = "x", s2 = "aa", s3 = "bb", s4 = "yy";
    string ssum = adder(s1, s2, s3, s4);
    cout<<"string sum="<<ssum<<endl;
    return 0;
}






#include <iostream>
using namespace std;
template <class T>
void fun(T a){
	cout << "The main template fun(): " << a << endl;
}
template<>
void fun(int a){
	cout << "Specialized Template for int type: "<< a << endl;
}
int main(){
	fun<char>('a');
	fun<int>(10);
	fun<float>(10.14);
	fun(45);
}

