Exercise: Employee Management System (Console-Based) using Modern C++:

Objective:
Design a simple employee management system in modern C++ that demonstrates the use of:
autoÂ type deduction
nullptr
enum class 
range-based for loop
smart pointers 
lambda expressions 
move semantics 


Step 1: Define aÂ DepartmentÂ usingÂ enum class
UseÂ enum class Department { HR, Finance, Engineering, Marketing };


Step 2: Create anÂ EmployeeÂ class
Attributes: ID, Name, Department, Salary
Add constructor, getters, and aÂ print()Â method


Step 3: Store Employees in aÂ vectorÂ usingÂ smart pointers
UseÂ std::unique_ptr<Employee>

(Create a Vector for the Employees)

Step 4: Populate the vector usingÂ std::make_unique<>

(Add a few employees to the system)

Step 5: Display all employees usingÂ range-based forÂ andÂ auto

Step 6: UseÂ lambdaÂ to sort employees by salary 
Step 7: DemonstrateÂ move semantics:
Move an employee from one list to another 













Exercise: Extend your Employee Management System in Modern C++ : STL:

Objective Recap:
Youâ€™ve already implemented:
enum class, unique_ptr, auto, nullptr, range-based for, lambda, and move semantics.

Extension Objectives:
Add the following:
STL Containers: set, map, unordered_map, multimap, multiset
Iterators: begin(), end(), advance(), next(), prev(), reverse iterators
Algorithms: find_if(), count_if(), sort(), transform(), accumulate(), partition(), for_each()

Suggested Steps with Code:

Step 1: Use std::map<int, Employee*> to index employees by ID
std::map<int, Employee*> employeeIndex;
for (const auto& emp : employees) {
    employeeIndex[emp->getID()] = emp.get();  // raw pointer for demo purpose
}

Step 2: Search using find_if() by Department
auto it = std::find_if(employees.begin(), employees.end(), [](const auto& emp) {
    return emp->getDepartment() == Department::Engineering;
});
if (it != employees.end())
    std::cout << "Engineering Employee: "; (*it)->print();

Step 3: Count Employees with Salary > 50000 using count_if()
int countHighEarners = std::count_if(employees.begin(), employees.end(), [](const auto& emp) {
    return emp->getSalary() > 50000;
});
std::cout << "High earning employees: " << countHighEarners << std::endl;

Step 4: Use std::transform() to give salary hike to all
std::for_each(employees.begin(), employees.end(), [](auto& emp) {
    emp->setSalary(emp->getSalary() * 1.10);  // 10% hike
});

Step 5: Display all Employees using Reverse Iterators
for (auto it = employees.rbegin(); it != employees.rend(); ++it) {
    (*it)->print();
}

Step 6: Use std::partition() to separate high earners
auto mid = std::partition(employees.begin(), employees.end(), [](const auto& emp) {
    return emp->getSalary() > 60000;
});
std::cout << "High Earners:\n";
std::for_each(employees.begin(), mid, [](const auto& emp) { emp->print(); });

Step 7: Use std::accumulate() to calculate total payroll
double totalSalary = std::accumulate(employees.begin(), employees.end(), 0.0, [](double sum, const auto& emp) {
    return sum + emp->getSalary();
});
std::cout << "Total Payroll: " << totalSalary << std::endl;

Step 8: Use std::set to store unique departments
std::set<Department> departments;
for (const auto& emp : employees) {
    departments.insert(emp->getDepartment());
}

Step 9: Use std::multimap for grouping employees by department
std::multimap<Department, std::string> deptMap;
for (const auto& emp : employees) {
    deptMap.insert({ emp->getDepartment(), emp->getName() });
}
std::cout << "Employees Grouped by Department:\n";
for (const auto& [dept, name] : deptMap) {
    std::cout << static_cast<int>(dept) << ": " << name << std::endl;
}

Step 10: Use Iterators explicitly to display names
std::cout << "Employee Names:\n";
for (auto it = employees.begin(); it != employees.end(); ++it) {
    std::cout << (*it)->getName() << std::endl;
}

Step 11: Store sorted salaries in std::vector using transform()
std::vector<double> salaries;
std::transform(employees.begin(), employees.end(), std::back_inserter(salaries), [](const auto& emp) {
    return emp->getSalary();
});
std::sort(salaries.begin(), salaries.end());









Goal: Add Design Patterns to Your Employee Management System
Design Patterns to Implement:
Strategy Pattern â€“ Flexible sorting or payroll computation strategies
Observer Pattern â€“ Notify HR when high-salary employees are added
Factory Pattern â€“ Encapsulate employee creation logic
Singleton Pattern â€“ Central payroll manager or configuration
Visitor Pattern â€“ Perform operations like bonus distribution, tax deduction, etc.
1. Strategy Pattern
Goal:
Dynamically choose sorting strategy (by name, by salary, etc.) at runtime.
Step:
Define a strategy interface.
Implement multiple strategies.
Inject the strategy dynamically.

2. Observer Pattern
Goal:
Notify HR or logger when high-salary employee is added.

Step:
Create Observer interface and concrete observer (e.g., HRLogger).

Subject class is EmployeeManager.

3. Factory Pattern
Goal:
Encapsulate creation of different types of Employees.

Step:
Create abstract factory method and concrete types.

4. Singleton Pattern
Goal:
Ensure one central PayrollManager exists.

Step:
Private constructor + static getInstance method.

5. Visitor Pattern
Goal:
Apply operations like bonus or tax without modifying Employee.

Step:
Define Visitor interface and concrete visitors.










Exercise: Employee Management System (Console-Based) using Modern C++:

Re design the exercise such that it follows SOLID principles: SRP, OCP, LSP, ISP, DIP
âœ… S â€” Single Responsibility Principle (SRP)
Each class should have one and only one reason to change.
ðŸ”¹ Steps:
Separate classes by responsibility:
Create a class Employee for storing employee data only.
Create a class EmployeePrinter to handle all printing/display logic.
Create a class EmployeeRepository to handle storage and data access (like add, remove, find).
Create a class EmployeeSorter to sort employees.
Create a class EmployeeAnalyzer to perform any analytics (like highest salary, count by department).
Â 
âœ… O â€” Open/Closed Principle (OCP)
Software entities should be open for extension but closed for modification.
ðŸ”¹ Steps:
Use polymorphism via abstract base classes or interfaces.
Define an abstract class ISorter with a method sort(std::vector<std::unique_ptr<Employee>>& employees).
Create SortBySalary, SortByName, etc., that inherit from ISorter.
To add new sorting logic (e.g., sort by Department), you can just add a new class without touching existing code.
Â 
âœ… L â€” Liskov Substitution Principle (LSP)
Derived classes must be substitutable for their base classes.
ðŸ”¹ Steps:
When using inheritance (e.g., if you create specialized employees: Manager, Intern, etc.), ensure:
All derived classes override behavior safely.
They do not break the expectations of base class consumers.
Example: Employee should define a virtual getRole() method, and all derived classes must return valid, consistent data.
Â 
âœ… I â€” Interface Segregation Principle (ISP)
Clients should not be forced to depend on interfaces they donâ€™t use.
ðŸ”¹ Steps:
Split fat interfaces:
Instead of having one class with too many responsibilities, split interfaces:
IPrintable
ISortable
ISearchable
Let classes only implement what they need.
Use templates or abstract base classes for interfaces in C++.
Â 
âœ… D â€” Dependency Inversion Principle (DIP)
High-level modules should not depend on low-level modules. Both should depend on abstractions.
ðŸ”¹ Steps:
Define interfaces/abstract classes like IRepository, ISorter, etc.
Inject these into high-level classes (like EmployeeManager) via constructor or setter.
Use dependency injection pattern to pass dependencies.
class EmployeeManager {
private:
    std::shared_ptr<IRepository> repo;
    std::shared_ptr<ISorter> sorter;
public:
    EmployeeManager(std::shared_ptr<IRepository> r, std::shared_ptr<ISorter> s)
        : repo(std::move(r)), sorter(std::move(s)) {}
};
Â 
ðŸ”§ Bonus: Useful STL and Modern C++ Features to Combine
std::function and lambdas to inject logic.
std::transform, std::accumulate, std::for_each for analytics and transformations.
std::set, std::map, etc., to organize employees by department or role.
Â 
ðŸ”„ Final Architecture (High-Level Classes)
Employee â€“ Core data model.
EmployeeRepository â€“ Stores and manages employees.
EmployeePrinter â€“ Responsible for display.
EmployeeSorter â€“ Sorts employees using strategy pattern.
IRepository / ISorter â€“ Abstract base interfaces.
EmployeeManager â€“ Orchestrates all logic and delegates work.
Â 

