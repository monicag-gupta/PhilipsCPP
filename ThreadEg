#include <iostream>
#include <thread>

int main() {
    unsigned int n = std::thread::hardware_concurrency();
    if (n == 0) {
        std::cout << "Number of concurrent threads not detectable.\n";
    } else {
        std::cout << "System supports " << n << " concurrent threads.\n";
    }
    return 0;
}





#include <iostream>
#include <thread>

// A simple function for a thread
void workerFunction(int id) {
    std::cout << "Worker " << id << " is running on thread ID " 
              << std::this_thread::get_id() << "\n";
}

int main() {
    std::thread t1(workerFunction, 1);  // Start a thread
    std::thread t2(workerFunction, 2);  // Start another

    t1.join();  // Wait for t1 to finish
    t2.join();  // Wait for t2 to finish

    return 0;
}


#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <mutex>

std::mutex coutMutex;

void doWork(int id, int duration) {
    {
        std::lock_guard<std::mutex> lock(coutMutex);
        std::cout << "Thread " << id << " starting on ID " 
                  << std::this_thread::get_id() << "\n";
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(duration));

    {
        std::lock_guard<std::mutex> lock(coutMutex);
        std::cout << "Thread " << id << " finished work.\n";
    }
}

int main() {
    std::cout << "Hardware threads available: " 
              << std::thread::hardware_concurrency() << "\n";

    std::vector<std::thread> workers;
    for (int i = 0; i < 5; ++i) {
        workers.emplace_back(doWork, i, 500 + i * 100);
    }

    for (auto& t : workers) {
        if (t.joinable()) {
            t.join();
        }
    }

    std::cout << "All threads finished.\n";
    return 0;
}






#include <iostream>
#include <thread> // includes std::jthread
#include <chrono>

void work(int id) {
    std::cout << "Thread " << id << " starting...\n";
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Thread " << id << " finished.\n";
}

int main() {
    std::jthread jt1(work, 1); // Automatically joins
    std::jthread jt2(work, 2); // No join() needed

    std::cout << "Main thread continuing...\n";


    return 0;
}












#include <iostream>
#include <thread>
#include <chrono>

void worker(std::stop_token stopToken, int id) {
    while (!stopToken.stop_requested()) {
        std::cout << "Thread " << id << " is working...\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
    std::cout << "Thread " << id << " stopping.\n";

}

int main() {
    std::jthread jt(worker, 1);

    std::this_thread::sleep_for(std::chrono::seconds(2));
    jt.request_stop(); // Ask the thread to stop

    // No need to call join() — automatic
    std::cout << "Main finished.\n";
}





#include <iostream>
#include <thread>
#include <mutex>
std::mutex mtx; // Global mutex
int counter = 0;
void increment(int id) {
    for (int i = 0; i < 5; ++i) {
        mtx.lock(); // Lock before accessing shared data
        ++counter;
        std::cout << "Thread " << id << " incremented counter to " << counter << "at iteration: " << i << "\n";
        mtx.unlock(); // Unlock after use
    }
}
int main() {
    std::thread t1(increment, 1);
    std::thread t2(increment, 2);
    t1.join();
    t2.join();
    std::cout << "Final counter value: " << counter << "\n";
}





#include <iostream>
#include <thread>
#include <mutex>
std::mutex mtx;
int counter = 0;
void increment(int id) {
    for (int i = 0; i < 5; ++i) {
        std::lock_guard<std::mutex> lock(mtx); // RAII - unlocks automatically
        ++counter;
        std::cout << "Thread " << id << " incremented counter to " << counter << "\n";
    }
}
int main() {
    std::thread t1(increment, 1);
    std::thread t2(increment, 2);
    t1.join();
    t2.join();
    std::cout << "Final counter value: " << counter << "\n";
}






#include <iostream>
#include <thread>
#include <mutex>

std::mutex m1, m2;

void task1() {
    std::cout << "Task 1 begins\n";
    std::lock_guard<std::mutex> lg1(m1);
    std::cout << "Task 1 locks m1\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work
    std::lock_guard<std::mutex> lg2(m2); // Waits here if task2 has m2
    std::cout << "Task 1 locks m2 in m1 locked\n";
    std::cout << "Task 1 completed\n";
}

void task2() {
    std::cout << "Task 2 begins\n";
    std::lock_guard<std::mutex> lg2(m2);
    std::cout << "Task 2 locks m2\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work
    std::lock_guard<std::mutex> lg1(m1); // Waits here if task1 has m1
    std::cout << "Task 2 locks m1 in m2 locked\n";
    std::cout << "Task 2 completed\n";
}

int main() {
    std::thread t1(task1);
    std::thread t2(task2);

    t1.join();
    t2.join();
}






#include <iostream>
#include <thread>
#include <mutex>
std::mutex m1, m2;
void task1() {
    std::scoped_lock lock(m1, m2); // Locks both without deadlock
    std::cout << "Task1 acquired both locks\n";
}
void task2() {
    std::scoped_lock lock(m1, m2); // Safe
    std::cout << "Task2 acquired both locks\n";
}
int main() {
    std::thread t1(task1);
    std::thread t2(task2);
    t1.join();
    t2.join();
}





#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
std::mutex mtx;
void tryLockTask(int id) {
    if (mtx.try_lock()) {
        std::cout << "Thread " << id << " got the lock\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        mtx.unlock();
    } else {
        std::cout << "Thread " << id << " could not get the lock\n";
    }
}
int main() {
    std::thread t1(tryLockTask, 1);
    std::thread t2(tryLockTask, 2);
    t1.join();
    t2.join();
}






#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <chrono>
std::mutex mtx; // shared mutex
int counter = 0;
void incrementTask(int id) {
    // Defer lock: Don't lock in constructor // Creates a lock object, but does not lock yet.
    std::unique_lock<std::mutex> lock(mtx, std::defer_lock);
    // Simulate some work before locking
    std::this_thread::sleep_for(std::chrono::milliseconds(50));    
    lock.lock(); // Lock explicitly
    ++counter;
    std::cout << "Thread " << id << " incremented counter to " << counter << "\n";    
    lock.unlock(); // Unlock early (before the scope ends)
    // Do some more work without holding the lock
    std::this_thread::sleep_for(std::chrono::milliseconds(30));    
    lock.lock(); // Lock again later if needed
    std::cout << "Thread " << id << " did more work safely.\n";
}
int main() {
    std::vector<std::thread> threads;
    for (int i = 1; i <= 5; ++i)
        threads.emplace_back(incrementTask, i);
    for (auto& t : threads)
        t.join();
    std::cout << "Final counter value: " << counter << "\n";
    return 0;
}





#include <iostream>
#include <thread>
#include <vector>
int counter = 0; // Not thread-safe
void increment() {
    for (int i = 0; i < 100000; ++i) {
        counter++; // Race condition here
    }
}
int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 4; ++i)
        threads.emplace_back(increment);
    for (auto& t : threads)
        t.join();
    std::cout << "Counter: " << counter << "\n"; // Likely < 400000 due to lost updates
}




#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
std::atomic<int> counter(0); // Thread-safe counter
void increment() {
    for (int i = 0; i < 100000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed); // Atomic increment
        // Alternatively: ++counter;
    }
}
int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 4; ++i)
        threads.emplace_back(increment);
    for (auto& t : threads)
        t.join();
    std::cout << "Counter: " << counter.load() << "\n"; // Always 400000
}






std::atomic Operations:

load() → Read value atomically.
store(value) → Write value atomically.
fetch_add(x) → Atomically add.
fetch_sub(x) → Atomically subtract.
exchange(x) → Atomically replace value.
compare_exchange_strong(expected, desired) → Compare-and-swap.








#include <iostream>
#include <future>
#include <thread>
#include <chrono>

int computeSum(int a, int b) {
    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulate work
    return a + b;
}
int main() {
    // Launch a task and get a future
    std::future<int> result = std::async(std::launch::async, computeSum, 10, 20);

    std::cout << "Doing something else while sum is calculated...\n";

    // Get the result (waits if not ready)
    std::cout << "Sum is: " << result.get() << "\n";
}






Breaking it down
std::future<int>
A future represents a value that will be computed in the future.
In this case, the value will be an int (because computeSum returns int).
You’ll retrieve it later with result.get().
std::async
Launches a function asynchronously.
Automatically handles thread creation and destruction.
std::launch::async
A launch policy telling C++ to definitely run the task in a separate thread right away.
Without it, C++ might run the function lazily (only when get() is called).
computeSum, 10, 20
The function and its arguments.
Works just like calling computeSum(10, 20) — except it happens on another thread.





#include <iostream>
#include <thread>
#include <future>
#include <chrono>
// Producer function
void produceValue(std::promise<int> p) {
    std::this_thread::sleep_for(std::chrono::seconds(2)); // simulate work
    std::cout << "[Producer] Setting the value...\n";
    p.set_value(42); // send value to future
}
// Consumer function
void consumeValue(std::future<int> f) {
    std::cout << "[Consumer] Waiting for value...\n";
    int value = f.get(); // blocks until value is set
    std::cout << "[Consumer] Received value: " << value << "\n";
}
int main() {
    std::promise<int> prom;             // Create promise
    std::future<int> fut = prom.get_future(); // Get its future
    std::thread producer(produceValue, std::move(prom)); // pass promise to producer
    std::thread consumer(consumeValue, std::move(fut));  // pass future to consumer
    producer.join();
    consumer.join();
    return 0;
}





#include <iostream>
#include <thread>
#include <future>
#include <chrono>
#include <vector>
// Producer function
void produceValue(std::promise<int> p) {
    std::this_thread::sleep_for(std::chrono::seconds(2)); // simulate work
    std::cout << "[Producer] Setting the value...\n";
    p.set_value(99); // send value to future
}
// Consumer function
void consumeValue(std::shared_future<int> sf, int id) {
    std::cout << "[Consumer " << id << "] Waiting for value...\n";
    int value = sf.get(); // all consumers get the same value
    std::cout << "[Consumer " << id << "] Received value: " << value << "\n";
}
int main() {
    std::promise<int> prom;                 // Create promise
    std::future<int> fut = prom.get_future(); // Get its future
    // Convert to shared_future so multiple threads can call get()
    std::shared_future<int> sf = fut.share();
    // Create consumers
    std::vector<std::thread> consumers;
    for (int i = 1; i <= 3; ++i) 
        consumers.emplace_back(consumeValue, sf, i);
    // Create producer
    std::thread producer(produceValue, std::move(prom));    
    producer.join(); // Join threads
    for (auto& t : consumers)  t.join();
    return 0;
}




#include <iostream>
#include <thread>
#include <future>
#include <vector>
#include <chrono>
// Producer function
void produceValue(int producerId, std::promise<int> p) {
    std::this_thread::sleep_for(std::chrono::milliseconds(500 * producerId));
    int value = producerId * 100;
    std::cout << "[Producer " << producerId << "] Setting value: " << value << "\n";
    p.set_value(value);
}
// Consumer function
void consumeValue(std::shared_future<int> sf, int consumerId, int producerId) {
    std::cout << "[Consumer " << consumerId << "] Waiting for value from Producer " << producerId << "...\n";
    int value = sf.get();
    std::cout << "[Consumer " << consumerId << "] Received from Producer " << producerId << ": " << value << "\n";
}
int main() {
    const int numProducers = 2;
    const int numConsumers = 3;
    // One promise+shared_future for each producer
    std::vector<std::promise<int>> promises(numProducers);
    std::vector<std::shared_future<int>> sharedFutures;
    for (auto& p : promises) {
        std::future<int> fut = p.get_future();
        sharedFutures.push_back(fut.share());
    }
    // Start producers
    std::vector<std::thread> producers;
    for (int i = 0; i < numProducers; ++i) {
        producers.emplace_back(produceValue, i + 1, std::move(promises[i]));
    }
    // Start consumers for each producer
    std::vector<std::thread> consumers;
    for (int pid = 0; pid < numProducers; ++pid) {
        for (int cid = 1; cid <= numConsumers; ++cid) {
            consumers.emplace_back(consumeValue, sharedFutures[pid], cid, pid + 1);
        }
    }
    // Join all threads
    for (auto& t : producers) t.join();
    for (auto& t : consumers) t.join();
    return 0;
}






























