#include <iostream>
#include <thread>

int main() {
    unsigned int n = std::thread::hardware_concurrency();
    if (n == 0) {
        std::cout << "Number of concurrent threads not detectable.\n";
    } else {
        std::cout << "System supports " << n << " concurrent threads.\n";
    }
    return 0;
}





#include <iostream>
#include <thread>

// A simple function for a thread
void workerFunction(int id) {
    std::cout << "Worker " << id << " is running on thread ID " 
              << std::this_thread::get_id() << "\n";
}

int main() {
    std::thread t1(workerFunction, 1);  // Start a thread
    std::thread t2(workerFunction, 2);  // Start another

    t1.join();  // Wait for t1 to finish
    t2.join();  // Wait for t2 to finish

    return 0;
}


#include <iostream>
#include <thread>
#include <vector>
#include <chrono>
#include <mutex>

std::mutex coutMutex;

void doWork(int id, int duration) {
    {
        std::lock_guard<std::mutex> lock(coutMutex);
        std::cout << "Thread " << id << " starting on ID " 
                  << std::this_thread::get_id() << "\n";
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(duration));

    {
        std::lock_guard<std::mutex> lock(coutMutex);
        std::cout << "Thread " << id << " finished work.\n";
    }
}

int main() {
    std::cout << "Hardware threads available: " 
              << std::thread::hardware_concurrency() << "\n";

    std::vector<std::thread> workers;
    for (int i = 0; i < 5; ++i) {
        workers.emplace_back(doWork, i, 500 + i * 100);
    }

    for (auto& t : workers) {
        if (t.joinable()) {
            t.join();
        }
    }

    std::cout << "All threads finished.\n";
    return 0;
}






#include <iostream>
#include <thread> // includes std::jthread
#include <chrono>

void work(int id) {
    std::cout << "Thread " << id << " starting...\n";
    std::this_thread::sleep_for(std::chrono::seconds(1));
    std::cout << "Thread " << id << " finished.\n";
}

int main() {
    std::jthread jt1(work, 1); // Automatically joins
    std::jthread jt2(work, 2); // No join() needed

    std::cout << "Main thread continuing...\n";


    return 0;
}












#include <iostream>
#include <thread>
#include <chrono>

void worker(std::stop_token stopToken, int id) {
    while (!stopToken.stop_requested()) {
        std::cout << "Thread " << id << " is working...\n";
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
    std::cout << "Thread " << id << " stopping.\n";

}

int main() {
    std::jthread jt(worker, 1);

    std::this_thread::sleep_for(std::chrono::seconds(2));
    jt.request_stop(); // Ask the thread to stop

    // No need to call join() â€” automatic
    std::cout << "Main finished.\n";
}





#include <iostream>
#include <thread>
#include <mutex>
std::mutex mtx; // Global mutex
int counter = 0;
void increment(int id) {
    for (int i = 0; i < 5; ++i) {
        mtx.lock(); // Lock before accessing shared data
        ++counter;
        std::cout << "Thread " << id << " incremented counter to " << counter << "at iteration: " << i << "\n";
        mtx.unlock(); // Unlock after use
    }
}
int main() {
    std::thread t1(increment, 1);
    std::thread t2(increment, 2);
    t1.join();
    t2.join();
    std::cout << "Final counter value: " << counter << "\n";
}





#include <iostream>
#include <thread>
#include <mutex>
std::mutex mtx;
int counter = 0;
void increment(int id) {
    for (int i = 0; i < 5; ++i) {
        std::lock_guard<std::mutex> lock(mtx); // RAII - unlocks automatically
        ++counter;
        std::cout << "Thread " << id << " incremented counter to " << counter << "\n";
    }
}
int main() {
    std::thread t1(increment, 1);
    std::thread t2(increment, 2);
    t1.join();
    t2.join();
    std::cout << "Final counter value: " << counter << "\n";
}






#include <iostream>
#include <thread>
#include <mutex>

std::mutex m1, m2;

void task1() {
    std::cout << "Task 1 begins\n";
    std::lock_guard<std::mutex> lg1(m1);
    std::cout << "Task 1 locks m1\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work
    std::lock_guard<std::mutex> lg2(m2); // Waits here if task2 has m2
    std::cout << "Task 1 locks m2 in m1 locked\n";
    std::cout << "Task 1 completed\n";
}

void task2() {
    std::cout << "Task 2 begins\n";
    std::lock_guard<std::mutex> lg2(m2);
    std::cout << "Task 2 locks m2\n";
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Simulate work
    std::lock_guard<std::mutex> lg1(m1); // Waits here if task1 has m1
    std::cout << "Task 2 locks m1 in m2 locked\n";
    std::cout << "Task 2 completed\n";
}

int main() {
    std::thread t1(task1);
    std::thread t2(task2);

    t1.join();
    t2.join();
}






#include <iostream>
#include <thread>
#include <mutex>
std::mutex m1, m2;
void task1() {
    std::scoped_lock lock(m1, m2); // Locks both without deadlock
    std::cout << "Task1 acquired both locks\n";
}
void task2() {
    std::scoped_lock lock(m1, m2); // Safe
    std::cout << "Task2 acquired both locks\n";
}
int main() {
    std::thread t1(task1);
    std::thread t2(task2);
    t1.join();
    t2.join();
}





#include <iostream>
#include <thread>
#include <mutex>
#include <chrono>
std::mutex mtx;
void tryLockTask(int id) {
    if (mtx.try_lock()) {
        std::cout << "Thread " << id << " got the lock\n";
        std::this_thread::sleep_for(std::chrono::seconds(1));
        mtx.unlock();
    } else {
        std::cout << "Thread " << id << " could not get the lock\n";
    }
}
int main() {
    std::thread t1(tryLockTask, 1);
    std::thread t2(tryLockTask, 2);
    t1.join();
    t2.join();
}






#include <iostream>
#include <thread>
#include <mutex>
#include <vector>
#include <chrono>
std::mutex mtx; // shared mutex
int counter = 0;
void incrementTask(int id) {
    // Defer lock: Don't lock in constructor // Creates a lock object, but does not lock yet.
    std::unique_lock<std::mutex> lock(mtx, std::defer_lock);
    // Simulate some work before locking
    std::this_thread::sleep_for(std::chrono::milliseconds(50));    
    lock.lock(); // Lock explicitly
    ++counter;
    std::cout << "Thread " << id << " incremented counter to " << counter << "\n";    
    lock.unlock(); // Unlock early (before the scope ends)
    // Do some more work without holding the lock
    std::this_thread::sleep_for(std::chrono::milliseconds(30));    
    lock.lock(); // Lock again later if needed
    std::cout << "Thread " << id << " did more work safely.\n";
}
int main() {
    std::vector<std::thread> threads;
    for (int i = 1; i <= 5; ++i)
        threads.emplace_back(incrementTask, i);
    for (auto& t : threads)
        t.join();
    std::cout << "Final counter value: " << counter << "\n";
    return 0;
}





#include <iostream>
#include <thread>
#include <vector>
int counter = 0; // Not thread-safe
void increment() {
    for (int i = 0; i < 100000; ++i) {
        counter++; // Race condition here
    }
}
int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 4; ++i)
        threads.emplace_back(increment);
    for (auto& t : threads)
        t.join();
    std::cout << "Counter: " << counter << "\n"; // Likely < 400000 due to lost updates
}




#include <iostream>
#include <thread>
#include <vector>
#include <atomic>
std::atomic<int> counter(0); // Thread-safe counter
void increment() {
    for (int i = 0; i < 100000; ++i) {
        counter.fetch_add(1, std::memory_order_relaxed); // Atomic increment
        // Alternatively: ++counter;
    }
}
int main() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 4; ++i)
        threads.emplace_back(increment);
    for (auto& t : threads)
        t.join();
    std::cout << "Counter: " << counter.load() << "\n"; // Always 400000
}






