#include <iostream>
#include <string>

class Student {
private:
    std::string name;
    int marks1;
    int marks2;

public:
    // Constructor
    Student(const std::string& name, int marks1, int marks2)
        : name(name), marks1(marks1), marks2(marks2) {}

    // 1. Responsible for printing student details (Presentation logic)
    void printDetails() const {
        std::cout << "Name: " << name << std::endl;
        std::cout << "Marks1: " << marks1 << std::endl;
        std::cout << "Marks2: " << marks2 << std::endl;
    }

    // 2. Responsible for calculating percentage (Business logic)
    void calculatePercentage() const {
        double percentage = (marks1 + marks2) / 2.0;
        std::cout << "Percentage: " << percentage << "%" << std::endl;
    }

    // 3. Responsible for adding a student (Persistence logic)
    void addStudent() const {
        // Simulating saving to a database
        std::cout << "Student " << name << " added to the database." << std::endl;
    }
};

// Example usage
int main() {
    Student s("Alice", 85, 90);
    s.printDetails();
    s.calculatePercentage();
    s.addStudent();

    return 0;
}






#include <iostream>
#include <string>
#include <memory>

// 1. Data class - Single Responsibility: Store Student Data
class Student {
private:
    std::string name;
    int marks1;
    int marks2;

public:
    Student(const std::string& name, int m1, int m2)
        : name(name), marks1(m1), marks2(m2) {
    }

    std::string getName() const { return name; }
    int getMarks1() const { return marks1; }
    int getMarks2() const { return marks2; }
};

// 2. Printer class - Single Responsibility: Presentation
class StudentPrinter {
public:
    void printDetails(const Student& student) const {
        std::cout << "Name: " << student.getName() << "\n";
        std::cout << "Marks1: " << student.getMarks1() << "\n";
        std::cout << "Marks2: " << student.getMarks2() << "\n";
    }
};

// 3. Calculator class - Single Responsibility: Business logic
class StudentCalculator {
public:
    double calculatePercentage(const Student& student) const {
        return (student.getMarks1() + student.getMarks2()) / 2.0;
    }
};

// 4. Repository class - Single Responsibility: Persistence
class StudentRepository {
public:
    void addStudent(const Student& student) const {
        // Simulate saving to database
        std::cout << "Student " << student.getName() << " added to database.\n";
    }
};

// ---- Example usage ----
int main() {
    Student student("John Doe", 80, 90);

    StudentPrinter printer;
    StudentCalculator calculator;
    StudentRepository repository;

    printer.printDetails(student);
    std::cout << "Percentage: " << calculator.calculatePercentage(student) << "%\n";
    repository.addStudent(student);

    return 0;
}







#include <iostream>
#include <memory>

class Vehicle {
public:
    virtual double getNumber() const = 0;
    virtual ~Vehicle() = default;
};

class Car : public Vehicle {
public:
    double getNumber() const override {
        return 1234;
    }
};

class Bike : public Vehicle {
public:
    double getNumber() const override {
        return 5678;
    }
};

class VehicleInfo {
public:
    double vehicleNumber(std::shared_ptr<Vehicle> vcl) {
        // Not in OCP - requires modification to add support for new vehicle types
        if (dynamic_cast<Car*>(vcl.get())) {
            return vcl->getNumber();
        }
        if (dynamic_cast<Bike*>(vcl.get())) {
            return vcl->getNumber();
        }
        return -1; // default case
    }
};

int main() {
    std::shared_ptr<Vehicle> car = std::make_shared<Car>();
    std::shared_ptr<Vehicle> bike = std::make_shared<Bike>();

    VehicleInfo info;
    std::cout << "Car Number: " << info.vehicleNumber(car) << std::endl;
    std::cout << "Bike Number: " << info.vehicleNumber(bike) << std::endl;

    return 0;
}





#include <iostream>
#include <memory>
#include <vector>

// Base class (open for extension)
class Vehicle {
public:
    virtual double getNumber() const = 0;
    virtual ~Vehicle() = default;
};

// Concrete classes (new types can be added without changing existing code)
class Car : public Vehicle {
public:
    double getNumber() const override {
        return 1234;
    }
};

class Bike : public Vehicle {
public:
    double getNumber() const override {
        return 5678;
    }
};

// VehicleInfo doesn't care what kind of Vehicle it is
class VehicleInfo {
public:
    double vehicleNumber(const Vehicle& vcl) {
        return vcl.getNumber();
    }
};

int main() {
    VehicleInfo info;

    // Create various vehicles
    std::vector<std::shared_ptr<Vehicle>> vehicles = {
        std::make_shared<Car>(),
        std::make_shared<Bike>()
    };

    // Display vehicle numbers
    for (const auto& v : vehicles) {
        std::cout << "Vehicle Number: " << info.vehicleNumber(*v) << std::endl;
    }

    return 0;
}






#include <iostream>
#include <vector>
#include <memory>
#include <stdexcept>

class Bird {
public:
    virtual void fly() {
        std::cout << "Bird is flying" << std::endl;
    }

    virtual void eat() {
        std::cout << "Bird is eating" << std::endl;
    }

    virtual ~Bird() = default;
};

class Crow : public Bird {
public:
    void fly() override {
        std::cout << "Crow is flying" << std::endl;
    }

    void eat() override {
        std::cout << "Crow is eating" << std::endl;
    }
};

class Ostrich : public Bird {
public:
    void fly() override {
        // Violation: Ostrich can't fly but is forced to implement it.
        throw std::runtime_error("Ostrich can't fly!");
    }

    void eat() override {
        std::cout << "Ostrich is eating" << std::endl;
    }
};

void letTheBirdsFly(const std::vector<std::shared_ptr<Bird>>& birds) {
    for (const auto& bird : birds) {
        bird->fly(); // Will throw error for Ostrich
    }
}

int main() {
    std::vector<std::shared_ptr<Bird>> birds;
    birds.push_back(std::make_shared<Bird>());
    birds.push_back(std::make_shared<Crow>());
    birds.push_back(std::make_shared<Ostrich>()); // Not substitutable for Bird in flying

    try {
        letTheBirdsFly(birds);
    } catch (const std::exception& e) {
        std::cout << "Exception: " << e.what() << std::endl;
    }

    return 0;
}









